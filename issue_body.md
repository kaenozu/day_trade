# コードレビューコメント

## 1. `src/day_trade/models/database.py`

### 良い点:
*   **明確な目的:** データベース接続とセッション管理に特化しており、役割が明確です。
*   **セッション管理:** `session_scope` コンテキストマネージャーが適切に実装されており、セッションのコミット、ロールバック、クローズが確実に実行されます。
*   **Alembic連携:** マイグレーション管理のためのAlembicとの連携が組み込まれています。
*   **テスト対応:** インメモリSQLiteデータベースのサポートがあり、テストが容易になっています。
*   **SQLite外部キー制約:** SQLiteで外部キー制約を明示的に有効にしている点は、データ整合性のために重要です。
*   **型ヒント:** 型ヒントが適切に使用されており、コードの可読性と保守性が向上しています。

### 改善点・考慮事項:
1.  **グローバルな `db_manager` インスタンス:**
    *   `db_manager = DatabaseManager()` というグローバルインスタンスは便利ですが、テストの際に異なるデータベース設定が必要な場合や、アプリケーションが大規模になった場合に柔軟性が低下する可能性があります。
    *   **推奨:** アプリケーションの規模が大きくなる場合は、`DatabaseManager` を依存性注入の対象とするか、テスト時にインスタンスを簡単に置き換えられる仕組みを検討してください。
2.  **`session_scope` の広範な例外処理:**
    *   `except Exception:` はすべての例外をキャッチするため、特定の問題を隠蔽する可能性があります。
    *   **推奨:** データベース関連の既知のエラーを個別に処理したい場合は、より具体的な例外（例: `sqlalchemy.exc.SQLAlchemyError`）をキャッチすることを検討してください。
3.  **`init_alembic` および `migrate` の `autogenerate`:**
    *   `autogenerate=True` は便利ですが、常に完璧ではなく、変更を見落としたり、不正確なマイグレーションを生成したりする可能性があります。
    *   **推奨:** 本番環境に適用する前に、自動生成されたマイグレーションを慎重にレビューすることを推奨します。
4.  **`alembic.ini` のパス:**
    *   `Config("alembic.ini")` は `alembic.ini` が現在の作業ディレクトリにあることを前提としています。スクリプトが異なるディレクトリから実行されると失敗する可能性があります。
    *   **推奨:** アプリケーション構造が複雑になる場合は、`alembic.ini` への絶対パスを指定するか、設定可能にすることを検討してください。
5.  **`current_revision` 内のインポート:**
    *   `from alembic.runtime.migration import MigrationContext` が関数内でインポートされています。
    *   **推奨:** 通常、依存関係を明確にするため、インポートはファイルの先頭にまとめるのが良いプラクティスです。
6.  **Docstringsとコメント:**
    *   Docstringsは存在し、概ね良好です。一部（例: `"""SQLiteの設定"""`）は簡潔すぎます。
    *   **推奨:** Docstringsは、関数の目的、理由、引数、戻り値を明確に説明するようにしてください。例えば、`_set_sqlite_pragma` については、「SQLite接続で外部キー制約が強制されるようにする」といった説明を追加すると良いでしょう。

## 2. `src/day_trade/data/stock_master.py`

### 良い点:
*   **明確な責務:** 銘柄マスタの追加、更新、検索、削除といったCRUD操作が明確に定義されています。
*   **データベースセッション管理:** `db_manager.session_scope()` を使用して、データベースセッションが適切に管理されています。
*   **既存チェックと更新:** `add_stock` メソッドで既存の銘柄をチェックし、存在する場合は更新せずに情報メッセージをログに出力しています。
*   **yfinance連携:** `fetch_and_update_stock_info` メソッドで `yfinance` を利用して外部から銘柄情報を取得し、マスタを更新する機能が実装されています。
*   **検索機能の充実:** コード、銘柄名、セクター、業種、複合条件での検索機能が提供されており、柔軟なデータアクセスが可能です。
*   **型ヒント:** 全体的に型ヒントが適切に使用されており、コードの可読性と保守性が向上しています。
*   **ロギング:** 各操作で適切なログメッセージが出力されており、デバッグや運用時の状況把握に役立ちます。

### 改善点・考慮事項:
1.  **`add_stock` メソッドの `session` 引数:**
    *   `add_stock` メソッドが `session` 引数を受け取り、内部で `_add_stock_with_session` を呼び出す構造になっています。これは、外部からセッションを渡したい場合と、内部でセッションを管理したい場合の両方に対応するためと考えられます。
    *   **推奨:** この設計は許容されますが、もし `add_stock` が常に新しいセッションを管理するべきであれば、`session` 引数を削除し、`_add_stock_with_session` をプライベートメソッドとしてのみ使用することを検討しても良いでしょう。現在の実装でも問題はありません。
2.  **`session.expunge(stock)` の多用:**
    *   多くのメソッドで `session.expunge(stock)` が使用されています。これは、セッションがクローズされた後も `Stock` オブジェクトを使用できるようにするためと考えられます。
    *   **考慮事項:** `expunge` はオブジェクトをセッションから切り離しますが、そのオブジェクトが関連するオブジェクト（リレーションシップ）をロードしようとすると `DetachedInstanceError` が発生する可能性があります。もし将来的に `Stock` オブジェクトが他の関連エンティティを持つようになった場合、`joinedload` や `selectinload` などのEager Loading戦略を検討する必要があります。現在のところ、`Stock` モデルが単純なため問題ないと思われます。
3.  **広範な例外処理:**
    *   `except Exception as e:` が多くのメソッドで使用されています。これは `database.py` と同様に、特定の問題を隠蔽する可能性があります。
    *   **推奨:** データベース操作に関するエラーであれば `sqlalchemy.exc.SQLALCHEMYError` など、より具体的な例外をキャッチすることを検討してください。
4.  **`fetch_and_update_stock_info` の市場区分推定:**
    *   `market = "東証プライム"` とハードコードされています。yfinanceから市場区分を取得できないため、これは妥当な暫定措置ですが、将来的に他の市場の銘柄を扱う場合や、より正確な市場区分が必要になった場合には、このロジックを見直す必要があります。
    *   **推奨:** 市場区分を特定するための別のデータソースやロジックを検討するか、ユーザーに手動で入力させるなどの対応が必要です。
5.  **`yfinance` のエラーハンドリング:**
    *   `yf.Ticker(symbol)` や `ticker.info` の呼び出しでネットワークエラーやAPI制限などが発生した場合の具体的なエラーハンドリングが不足しています。
    *   **推奨:** `try-except` ブロック内で `requests.exceptions.RequestException` や `yfinance` 固有の例外をキャッチし、リトライメカニズムや適切なエラーメッセージのロギングを実装することを検討してください。
6.  **`StockMasterManager` の初期化:**
    *   `__init__` メソッドが `pass` されています。これは問題ありませんが、将来的に依存関係が増える場合（例: 外部APIクライアントなど）は、ここで初期化を行うことになります。

## 3. `src/day_trade/data/stock_fetcher.py`

### 良い点:
*   **明確な責務:** 株価データの取得に特化しており、リアルタイムデータ、ヒストリカルデータ、企業情報の取得機能を提供しています。
*   **堅牢なエラーハンドリング:**
    *   カスタム例外クラス (`StockFetcherError`, `NetworkError`, `InvalidSymbolError`, `DataNotFoundError`) を定義し、エラーの種類を明確にしています。
    *   `_retry_on_error` メソッドによるリトライ機構と指数バックオフが実装されており、一時的なネットワーク問題に対応できます。
    *   `_handle_error` メソッドで、発生した例外を適切なカスタム例外に変換しています。
*   **キャッシュ機構:**
    *   `DataCache` クラスと `cache_with_ttl` デコレータにより、TTL（Time-To-Live）付きのキャッシュが実装されています。これにより、APIへの不要なリクエストを減らし、パフォーマンスを向上させています。
    *   `lru_cache` も併用されており、効率的なキャッシュ戦略が取られています。
*   **入力値検証:** `_validate_symbol`, `_validate_date_range`, `_validate_period_interval` といったメソッドで、入力値の妥当性チェックが行われています。
*   **yfinanceとの連携:** `yfinance` ライブラリを効果的に利用し、株価データの取得を実現しています。
*   **型ヒント:** 全体的に型ヒントが適切に使用されており、コードの可読性と保守性が向上しています。
*   **ロギング:** 各操作で適切なログメッセージが出力されており、デバッグや運用時の状況把握に役立ちます。
*   **`if __name__ == "__main__":` ブロック:** モジュールのテストと使用例が示されており、開発者が機能を理解しやすくなっています。

### 改善点・考慮事項:
1.  **`DataCache` クラスの `any` 型ヒント:**
    *   `get` メソッドと `set` メソッドの `value: any` は、より具体的な型ヒントに置き換えることが望ましいです。
    *   **推奨:** 汎用的なキャッシュであるため難しいかもしれませんが、可能であれば `TypeVar` を使用して型を制約するか、ドキュメントでどのような型が格納されるかを明記すると良いでしょう。
2.  **`cache_with_ttl` デコレータのキャッシュキー生成:**
    *   `cache_key = f"{func.__name__}:{str(args)}:{str(sorted(kwargs.items()))}"` は、引数の順序や型、辞書の順序に依存するため、意図しないキャッシュミスや衝突が発生する可能性があります。特に、`args` や `kwargs` に複雑なオブジェクトが含まれる場合、`str()` 変換が常に一意で安定したキーを生成するとは限りません。
    *   **推奨:** キャッシュキーの生成には、引数のハッシュ値を使用するなど、より堅牢な方法を検討してください。例えば、`json.dumps` を使用して引数をシリアライズし、そのハッシュ値を取る方法などがあります。ただし、引数がシリアライズ可能である必要があります。
3.  **`_is_retryable_error` のエラーメッセージ解析:**
    *   エラーメッセージの文字列解析 (`str(error).lower()`) に依存してリトライ可能かどうかを判断しています。これは、yfinanceやrequestsライブラリの内部実装に依存するため、将来的にライブラリのバージョンアップでエラーメッセージが変わると、リトライロジックが機能しなくなる可能性があります。
    *   **推奨:** 可能であれば、例外の型 (`type(e)`) や、例外オブジェクトが持つ特定の属性をチェックするなど、より堅牢な方法でエラーの種類を判断することを検討してください。
4.  **`_handle_error` のエラーメッセージ解析:**
    *   こちらも同様にエラーメッセージの文字列解析に依存しています。
    *   **推奨:** `_is_retryable_error` と同様に、例外の型による判断を優先すべきです。
5.  **`get_current_price` の `info` 辞書チェック:**
    *   `if not info or len(info) < 5:` というチェックは、`yfinance` のAPI応答が将来的に変更された場合に脆弱になる可能性があります。
    *   **推奨:** 必要なキーがすべて存在するかどうかを明示的にチェックする方が安全です。例: `if not all(k in info for k in ["currentPrice", "previousClose", ...]):`
6.  **`get_realtime_data` の逐次処理:**
    *   複数の銘柄のリアルタイムデータを取得する際に、`get_current_price` をループで呼び出しています。これにより、各銘柄ごとにAPIリクエストとリトライ処理が発生し、効率が低下する可能性があります。
    *   **推奨:** `yfinance` の `download` 関数は複数のシンボルを一度に取得できるため、これを利用して一括でデータを取得し、処理する方が効率的です。リアルタイムデータの場合、`yfinance` の `Tickers` オブジェクトを使用することも検討できます。
7.  **`_validate_period_interval` のエラーメッセージ:**
    *   エラーメッセージに有効な期間と間隔のリストを直接含めていますが、リストが非常に長くなるとメッセージが読みにくくなる可能性があります。
    *   **推奨:** エラーメッセージは簡潔にし、詳細な情報はドキュメントやヘルプメッセージで提供することを検討してください。

## 4. `src/day_trade/analysis/indicators.py`

### 良い点:
*   **明確な責務:** テクニカル指標の計算に特化しており、各指標が静的メソッドとして独立して実装されています。
*   **Pandasの活用:** `pandas.DataFrame` と `pandas.Series` を効果的に使用しており、データ操作が効率的かつ簡潔に記述されています。
*   **主要な指標の網羅:** SMA, EMA, ボリンジャーバンド, MACD, RSI, ストキャスティクス, 出来高分析, ATRといった主要なテクニカル指標が実装されています。
*   **`calculate_all` メソッド:** 複数の指標を一括で計算する便利なメソッドが提供されており、分析のワークフローを簡素化できます。
*   **`if __name__ == "__main__":` ブロック:** サンプルデータの生成と各指標の計算例が示されており、モジュールの使い方を理解しやすいです。
*   **型ヒント:** 型ヒントが適切に使用されており、コードの可読性と保守性が向上しています。

### 改善点・考慮事項:
1.  **広範な例外処理:**
    *   各メソッドで `except Exception as e:` を使用してエラーをキャッチし、`pd.Series(dtype=float)` や `pd.DataFrame()` を返しています。これは、計算中に発生する可能性のある特定のPandasエラー（例: 列が存在しない、データが不足しているなど）を隠蔽し、デバッグを困難にする可能性があります。
    *   **推奨:**
        *   計算に必要な列が存在するかどうかを事前にチェックし、存在しない場合は `KeyError` などの具体的な例外を発生させる。
        *   データが不足している場合（例: `period` よりもデータポイントが少ない場合）は、Pandasが自動的に `NaN` を返すため、明示的なエラー処理は不要な場合が多いです。
        *   予期せぬエラーが発生した場合に備えて `Exception` をキャッチするのは良いですが、エラーメッセージをより詳細にし、可能であればエラーの種類に応じて異なる処理を行うことを検討してください。
2.  **RSIとATRの計算ロジック:**
    *   RSIとATRの計算において、`for` ループを使用して移動平均を計算している部分があります。Pandasの `ewm` (Exponential Weighted Moving) や `rolling` メソッドをより活用することで、よりPandasらしい（idiomatic）かつ高速な実装が可能です。特に、RSIの `avg_gain` と `avg_loss` の計算は、`ewm` を使用することで簡潔に記述できます。
    *   **推奨:**
        *   RSI: `ewm(com=period-1).mean()` を使用して指数移動平均を計算する。
        *   ATR: `ewm(com=period-1).mean()` を使用してTrue Rangeの指数移動平均を計算する。
3.  **`column` 引数のデフォルト値:**
    *   多くのメソッドで `column: str = 'Close'` がデフォルト値として設定されていますが、`stochastic` や `atr` のように `High`, `Low`, `Close` の複数列を必要とするメソッドでは、`column` 引数が使用されていません。
    *   **推奨:** `stochastic` や `atr` のDocstringに、必要な列 (`High`, `Low`, `Close`) を明記し、`column` 引数を削除するか、これらのメソッドでは `column` 引数を受け取らないようにする。
4.  **`calculate_all` メソッドの引数名:**
    *   `calculate_all` メソッドの引数名が `sma_periods`, `ema_periods`, `bb_period` など、各指標のメソッドの引数名と一致しており、一貫性があります。
    *   **考慮事項:** 引数の数が多いため、将来的に新しい指標が追加された場合に引数が増え続ける可能性があります。辞書形式でパラメータを渡すなど、引数をまとめる方法も検討できますが、現在の実装でも十分理解しやすいです。
5.  **Docstringsの改善:**
    *   Docstringsは存在しますが、一部の引数（例: `calculate_all` の `各種パラメータ`）については、もう少し詳細な説明があると親切です。
    *   **推奨:** 各引数の型と簡単な説明を追加する。

## 5. `src/day_trade/utils/formatters.py`

### 良い点:
*   **明確な責務:** 表示フォーマットに特化しており、通貨、パーセンテージ、出来高のフォーマットや、Richライブラリを使ったテーブル生成など、UI表示に必要なユーティリティがまとめられています。
*   **Richライブラリの活用:** `rich` ライブラリを効果的に使用し、CLIでの見やすい出力（色分けされたテキスト、整形されたテーブル、パネル）を実現しています。
*   **汎用的なフォーマット関数:** `format_currency`, `format_percentage`, `format_volume` は、様々な場所で再利用可能な汎用的な関数として設計されています。
*   **`None` 値のハンドリング:** 各フォーマット関数で `None` 値が渡された場合に "N/A" を返すようにしており、堅牢性が高いです。
*   **色分けロジック:** `get_change_color` 関数で変化値に基づいて色を決定するロジックが分離されており、再利用性があります。
*   **型ヒント:** 型ヒントが適切に使用されており、コードの可読性と保守性が向上しています。

### 改善点・考慮事項:
1.  **`format_currency` の通貨記号:**
    *   `format_currency` 関数で `currency` 引数が文字列として渡され、そのまま金額の後ろに付加されています。日本の通貨記号は通常金額の前に置かれることが多いです（例: ¥1,000）。
    *   **推奨:** `currency` 引数に応じて通貨記号の位置を調整するロジックを追加するか、`currency` 引数を記号そのものではなく、国コード（例: "JP", "US"）として受け取り、内部で適切な記号と位置を決定する方がより柔軟になります。
2.  **`create_historical_data_table` のパフォーマンス:**
    *   `create_historical_data_table` 内で `df.index.get_loc(idx) - 1` を使用して前日のインデックスを取得し、`df.loc[prev_idx, 'Close']` で前日終値を取得しています。これはループ内で実行されるため、DataFrameが非常に大きい場合にパフォーマンスのボトルネックになる可能性があります。
    *   **推奨:** `df['Close'].shift(1)` を使用して前日終値を事前に計算し、新しい列としてDataFrameに追加しておくことで、ループ内のアクセスを高速化できます。
3.  **`create_historical_data_table` の `max_rows`:**
    *   `max_rows` がデフォルトで10に設定されています。これはCLIでの表示には適切ですが、ユーザーがより多くの行を見たい場合に柔軟性がありません。
    *   **考慮事項:** ユーザーが `max_rows` を指定できるようにするか、または別のコマンドで全データを表示する機能を提供することを検討してください。
4.  **`create_stock_info_table` と `create_company_info_table` の重複ロジック:**
    *   両方の関数で `stock_data.get('key')` や `company_data.get('key')` を使用してデータを取得し、`if value:` で存在チェックをしてから `table.add_row` しています。このパターンが繰り返されています。
    *   **推奨:** 共通のヘルパー関数を作成し、辞書と表示項目（キーと表示名）のリストを渡すことで、コードの重複を減らすことができます。
5.  **`format_volume` の丸め処理:**
    *   `volume / 1_000_000:.1f` や `volume / 1_000:.1f` で小数点以下1桁に丸めていますが、これは常に適切とは限りません。例えば、999K の次は 1.0M となりますが、999,999 の場合は 1.0M と表示されるべきか、あるいは 0.999M と表示されるべきか、要件によって異なります。
    *   **考慮事項:** 丸め処理の精度や、特定の閾値での表示形式について、ユーザーの要件を確認してください。

## 6. `src/day_trade/utils/validators.py`

### 良い点:
*   **明確な責務:** 入力値の妥当性検証に特化しており、証券コード、期間、間隔の検証機能を提供しています。
*   **正規表現の活用:** `validate_stock_code` で正規表現を使用し、柔軟なコード形式に対応しています。
*   **正規化と修正候補の提案:** `normalize_stock_codes` と `suggest_stock_code_correction` は、ユーザー入力の利便性を高める良い機能です。
*   **型ヒント:** 型ヒントが適切に使用されており、コードの可読性と保守性が向上しています。

### 改善点・考慮事項:
1.  **`validate_stock_code` の正規表現の意図:**
    *   現在、`^\d{4}(\.T)?$` (4桁数字+オプション.T) と `^[A-Z0-9]{1,10}(\.T)?$` (1-10桁英数字+オプション.T) の2つのパターンで検証しています。後者のパターンは非常に広範であり、日本株以外の銘柄コード（例: 米国株）も考慮している可能性があります。
    *   **推奨:** もし日本株（東証）のみを対象とするのであれば、`^\d{4}(\.T)?$` のみで十分であり、より厳密な検証が可能です。もし多様な市場の銘柄を扱うのであれば、その旨をDocstringに明記するか、市場ごとに異なる検証ロジックを適用することを検討してください。
現在の実装では、例えば "ABC" や "12345ABC" といったコードも有効と判断されますが、これが意図通りか確認が必要です。
2.  **`validate_period` と `validate_interval` の有効値リストの重複:**
    *   これらの関数で使用されている `valid_periods` と `valid_intervals` のリストは、`src/day_trade/data/stock_fetcher.py` にも同様に定義されています。
    *   **推奨:** これらのリストを定数として一箇所（例: `src/day_trade/core/constants.py` のようなファイル）に定義し、両方のモジュールからインポートして使用することで、一貫性を保ち、変更時の手間を削減できます。
3.  **バリデーション結果の詳細化:**
    *   現在のバリデーション関数は `True` または `False` を返します。CLIアプリケーションでは、入力が不正だった場合に、なぜ不正なのか（例: 「無効な期間です。有効な期間は...です」）をユーザーに伝えることが重要です。
    *   **推奨:** バリデーションが失敗した場合に、エラーメッセージ文字列を返すか、カスタム例外を発生させるように変更することを検討してください。これにより、呼び出し元でよりユーザーフレンドリーなエラーメッセージを表示できます。
4.  **`normalize_stock_codes` の処理:**
    *   `normalize_stock_codes` は、`validate_stock_code` を呼び出して有効なコードのみを正規化していますが、無効なコードは単にスキップされます。ユーザーが入力したコードがスキップされた場合、ユーザーはなぜそのコードが処理されなかったのか理解できない可能性があります。
    *   **推奨:** 無効なコードがあった場合に、ログに警告を出力するか、無効なコードのリストを返すなど、ユーザーにフィードバックを提供する仕組みを追加することを検討してください。
5.  **`suggest_stock_code_correction` のロジック:**
    *   4桁の数字に `.T` を追加する提案と、小文字を大文字にする提案の2つがあります。
    *   **考慮事項:** これらの提案は便利ですが、ユーザーが意図しない修正を適用してしまう可能性もあります。CLIでユーザーに修正を提案し、確認を求めるフローを検討するとより安全です。

## 7. `src/day_trade/core/watchlist.py`

### 良い点:
*   **明確な責務:** ウォッチリストの管理に特化しており、追加、削除、取得、更新、グループ操作といった機能が明確に定義されています。
*   **データベースセッション管理:** `db_manager.session_scope()` を使用して、データベースセッションが適切に管理されています。
*   **重複チェック:** `add_stock` メソッドで、同じ銘柄が同じグループに既に存在しないかチェックしています。
*   **銘柄マスタとの連携:** ウォッチリストに追加する際に、銘柄が銘柄マスタに存在しない場合、`StockFetcher` を利用して情報を取得し、自動的に銘柄マスタに追加するロジックは非常に便利です。
*   **価格情報との統合:** `get_watchlist_with_prices` メソッドで、ウォッチリスト情報とリアルタイム価格情報を統合して提供しており、表示層での利用が容易です。
*   **型ヒント:** 型ヒントが適切に使用されており、コードの可読性と保守性が向上しています。

### 改善点・考慮事項:
1.  **広範な例外処理と `print` ステートメント:**
    *   多くのメソッドで `except Exception as e:` を使用してエラーをキャッチし、`print` ステートメントでエラーメッセージを出力しています。これは、エラーの種類を特定しにくく、アプリケーション全体でのエラーハンドリングの一貫性を損なう可能性があります。また、CLIアプリケーションでは `print` ではなく、`logging` モジュールを使用する方が一般的です。
    *   **推奨:**
        *   `logging` モジュールを使用してエラーをログに出力するように変更してください。
        *   カスタム例外クラスを定義し、より具体的なエラーを発生させるように変更することで、呼び出し元で適切なエラー処理を行えるようにすることを検討してください。
2.  **`add_stock` での `Stock` オブジェクトの `flush`:**
    *   `session.flush()` を使用して `Stock` オブジェクトのIDを取得していますが、`WatchlistItem` の追加と同時にコミットされるため、明示的な `flush` は必須ではありません。ただし、`Stock` オブジェクトが `WatchlistItem` の外部キーとして参照される前にIDが必要な場合は有効です。
    *   **考慮事項:** 現在のコードでは問題ありませんが、`flush` の必要性を再確認し、不要であれば削除することでコードを簡潔にできます。
3.  **`get_watchlist` での `item.stock` の存在チェック:**
    *   `item.stock.name if item.stock else item.stock_code` のように `item.stock` の存在チェックを行っていますが、`join(Stock)` を使用しているため、通常 `item.stock` は `None` にならないはずです。もし `Stock` が見つからない場合は、`join` の種類（例: `outerjoin`）やデータベースのデータ整合性を確認する必要があります。
    *   **推奨:** `item.stock` が常に存在することを前提とするか、もし `Stock` が存在しないケースがあり得るなら、その理由を明確にし、適切なエラーハンドリングやデータ修正を検討してください。
4.  **`get_watchlist_with_prices` の効率性:**
    *   `get_realtime_data` を呼び出して価格情報を取得していますが、`stock_fetcher.py` のレビューで指摘したように、`get_realtime_data` はループ内で `get_current_price` を呼び出しているため、複数の銘柄の価格取得に時間がかかる可能性があります。
    *   **推奨:** `stock_fetcher.py` の `get_realtime_data` を改善し、複数の銘柄の価格を一括で効率的に取得できるようにすることで、このメソッドのパフォーマンスも向上します。
5.  **`move_to_group` の重複チェック:**
    *   移動先に同じ銘柄が既に存在するかチェックしていますが、その場合は `False` を返して処理を終了しています。
    *   **考慮事項:** ユーザー体験として、既に存在する場合はエラーメッセージを出すか、上書きするかなどの選択肢を提供することを検討しても良いでしょう。

## 8. `src/day_trade/core/config.py`

### 良い点:
*   **Pydanticの活用:** Pydantic を使用して設定のスキーマを定義している点が非常に優れています。これにより、設定の型安全性、バリデーション、デフォルト値の管理が容易になり、コードの堅牢性が大幅に向上しています。
*   **設定の階層化:** `TradingConfig`, `DisplayConfig`, `APIConfig` といったネストされた設定モデルにより、設定が論理的に整理されており、可読性が高いです。
*   **デフォルト値の管理:** `Field` を使用してデフォルト値を設定し、説明を追加しているため、設定の意図が明確です。
*   **設定ファイルの自動生成:** 設定ファイルが存在しない場合にデフォルト設定で初期化されるため、初回起動時の手間が省けます。
*   **ドット記法でのアクセス:** `get` および `set` メソッドにより、ネストされた設定値にドット記法 (`trading.tax_rate` など) でアクセスできるのは非常に便利です。
*   **設定の更新機能:** `update_config` メソッドがネストされた辞書の更新に対応しており、部分的な設定変更が容易です。
*   **ユーザーディレクトリへの保存:** `Path.home() / ".daytrade"` を使用してユーザーのホームディレクトリに設定ファイルを保存するアプローチは、クロスプラットフォームで適切です。
*   **エクスポート/インポート機能:** 設定のエクスポートとインポート機能は、設定のバックアップや異なる環境間での共有に役立ちます。
*   **型ヒント:** 全体的に型ヒントが適切に使用されており、コードの可読性と保守性が向上しています。

### 改善点・考慮事項:
1.  **設定ファイル読み込み時のエラーハンドリング:**
    *   `load_config` メソッドで設定ファイルの読み込みエラーが発生した場合、`print` でエラーメッセージを出力し、`AppConfig()` のデフォルト設定を返しています。これは、エラーが発生したことをユーザーに伝えるには十分ですが、エラーの詳細がログに残らないため、デバッグが困難になる可能性があります。
    *   **推奨:** `logging` モジュールを使用してエラーをログに出力するように変更してください。
    *   また、設定ファイルのフォーマットエラーなど、回復不能なエラーの場合は、アプリケーションを終了させるか、より明確なエラーメッセージをユーザーに表示することを検討してください。
2.  **`update_config` の `update_nested` 関数:**
    *   `update_nested` 関数は、Pydantic モデルの `model_dump()` で得られた辞書を直接操作しています。その後、その辞書を再度 `AppConfig(**config_dict)` でPydanticモデルに変換しています。このアプローチは機能しますが、Pydanticモデルのインスタンスを直接更新する方がよりPydanticらしい（idiomatic）かもしれません。
    *   **推奨:** Pydantic モデルの `copy(update=...)` メソッドや、フィールドを直接設定する方法を検討してください。
これにより、`model_dump()` と `AppConfig(**data)` の間の変換オーバーヘッドを減らし、コードをより簡潔にできる可能性があります。
3.  **`get` メソッドの `default` 引数:**
    *   `get` メソッドは `default` 引数を受け取りますが、ネストされたキーが存在しない場合に `default` を返すロジックは適切です。
    *   **考慮事項:** `get` メソッドが `model_dump()` を呼び出しているため、毎回辞書が生成されます。パフォーマンスがクリティカルな場合は、Pydanticモデルの属性に直接アクセスする方が高速ですが、現在の実装でもほとんどのユースケースでは問題ないでしょう。
4.  **`set` メソッドの `update_config` 呼び出し:**
    *   `set` メソッドは、設定値を更新するために `update_config` を呼び出しています。`update_config` は `save_config` を呼び出すため、`set` を呼び出すたびに設定ファイルがディスクに書き込まれます。頻繁に `set` が呼び出される場合、I/Oオーバーヘッドが発生する可能性があります。
    *   **推奨:** `set` メソッドで設定値を変更した後、明示的に `save_config()` を呼び出すようにするか、または設定変更をバッチ処理して、一度に保存するメカニズムを導入することを検討してください。
5.  **`DEFAULT_CONFIG_DIR` の隠しファイル/ディレクトリ:**
    *   `Path.home() / ".daytrade"` はLinux/macOSでは隠しディレクトリになりますが、Windowsでは隠しディレクトリにはなりません。
    *   **考慮事項:** Windowsユーザーにとって、`.daytrade` ディレクトリが通常のディレクトリとして表示されることに違和感がないか確認してください。もし隠したい場合は、Windows固有のAPIを使用する必要がありますが、これは複雑になる可能性があります。

## 9. `src/day_trade/cli/main.py` および `src/day_trade/cli/enhanced_main.py`

### 良い点:
*   **Clickフレームワークの活用:** `click` を使用してCLIコマンドが構造化されており、コマンドライン引数やオプションの定義が簡潔で分かりやすいです。
*   **Richライブラリの活用:** `rich` ライブラリを効果的に使用し、CLIの出力が視覚的に魅力的で、ユーザーにとって分かりやすいものになっています（色分け、テーブル、ステータス表示など）。
*   **責務の分離:** `StockFetcher`, `config_manager`, `validators`, `formatters` といった他のモジュールから機能をインポートして使用しており、各モジュールの責務が適切に分離されています。
*   **入力検証:** `validate_stock_code`, `validate_period`, `validate_interval` といったバリデーション関数を使用して、ユーザー入力の妥当性をチェックしています。
*   **ユーザーフレンドリーなエラーメッセージ:** `create_error_panel` を使用して、エラーメッセージが目立つように表示され、ユーザーに問題が明確に伝わります。
*   **設定管理との連携:** `config` コマンドを通じてアプリケーションの設定を表示、変更、リセットできる機能は非常に便利です。
*   **`watchlist_commands` のインポート:** `watchlist_commands.py` を別ファイルに分離し、`cli.add_command(watchlist)` で追加するアプローチは、CLIコマンドが増えた場合のコードの整理に役立ちます。
*   **`@click.version_option`:** バージョン表示機能が簡単に提供されています。

### 改善点・考慮事項:
1.  **`cli` グループの `config` オプションの利用:**
    *   `@click.option("--config", "-c", type=click.Path(), help="設定ファイルのパス")` で設定ファイルのパスを受け取っていますが、`config_manager` はグローバルインスタンスとして初期化されており、このオプションで渡されたパスが `config_manager` に反映されていません。
    *   **推奨:** `config_manager` の初期化を `cli` コマンドの実行時に行い、`config` オプションで指定されたパスを `ConfigManager` のコンストラクタに渡すように変更する必要があります。これにより、ユーザーが任意のパスに設定ファイルを指定できるようになります。
2.  **エラーハンドリングの一貫性:**
    *   `init` コマンドでは `try-except` でエラーをキャッチし `create_error_panel` を使用していますが、他のコマンド（例: `stock`, `history`, `watch`, `config export`, `config import`）では、下位レイヤーで発生したエラーがそのまま `create_error_panel` に渡される形になっています。`StockFetcher` や `ConfigManager` はカスタム例外を発生させるため、それらを適切にキャッチして、よりユーザーフレンドリーなメッセージに変換することを検討してください。
    *   **推奨:** 各コマンドで `StockFetcherError` やそのサブクラスをキャッチし、エラーの種類に応じて異なるメッセージを表示するなど、より詳細なエラーハンドリングを行う。
3.  **`stock` および `history` コマンドでの `normalize_stock_codes` の冗長な呼び出し:**
    *   `validate_stock_code` で検証した後、再度 `normalize_stock_codes` を呼び出しています。`validate_stock_code` が `True` を返した場合、`normalize_stock_codes` は必ず有効なコードを返すはずなので、この二重のチェックは冗長です。
    *   **推奨:** `normalize_stock_codes` を先に呼び出し、その結果が空でないことを確認してから処理を進めるか、`validate_stock_code` の中で正規化も行うようにロジックを統合することを検討してください。
4.  **`config_set` の型推定ロジック:**
    *   `config_set` コマンドで `value` の型を簡易的に推定していますが、これは限定的であり、例えばリストや辞書などの複雑な型には対応していません。
    *   **考慮事項:** より複雑な型をサポートする必要がある場合、JSON形式の文字列をパースするなどのより堅牢な方法を検討するか、Pydanticのバリデーション機能を活用することを検討してください。
5.  **`validate` コマンドの出力:**
    *   `validate` コマンドは、`normalize_stock_codes` と `suggest_stock_code_correction` の結果をそのまま表示しています。`normalize_stock_codes` が空のリストを返す場合、`normalized_str` が "N/A" となりますが、これはユーザーにとって分かりにくいかもしれません。
    *   **推奨:** `normalize_stock_codes` が空の場合、なぜ正規化できなかったのか（例: 無効な形式のため）を `suggestion_str` に含めるなど、より詳細な情報を提供する。
6.  **`main()` 関数の存在意義:**
    *   `main()` 関数が単に `cli()` を呼び出しているだけです。これは `if __name__ == "__main__":` ブロックで直接 `cli()` を呼び出すのと機能的には同じです。
    *   **考慮事項:** この `main()` 関数は、テストの際に `cli` を直接呼び出すためのフックとして残している可能性もありますが、もしそうでないなら削除しても問題ありません。

## 10. `src/day_trade/cli/watchlist_commands.py`

### 良い点:
*   **Clickフレームワークの活用:** `click` を使用してウォッチリスト関連のコマンドがグループ化され、サブコマンドとして整理されています。これにより、CLIの構造が明確で、機能の追加や管理が容易です。
*   **Richライブラリの活用:** `rich` を使用して、成功/エラーパネル、整形されたテーブル、プロンプトなど、ユーザーフレンドリーなCLI出力が実現されています。
*   **責務の分離:** `WatchlistManager` からビジネスロジックを呼び出し、`validators` や `formatters` からユーティリティ関数をインポートして使用しており、各モジュールの責務が適切に分離されています。
*   **入力検証と正規化:** `validate_stock_code` や `normalize_stock_codes` を使用して、ユーザー入力の妥当性をチェックし、正規化しています。
*   **複数銘柄の一括処理:** `add` や `remove` コマンドで複数の銘柄コードを一括で処理できるのは便利です。
*   **ユーザーへのフィードバック:** 成功/失敗メッセージが明確に表示され、失敗した銘柄コードもユーザーに伝えられます。
*   **対話型入力:** `memo` コマンドで `Prompt.ask` を使用して対話的にメモを入力できるのは、ユーザーエクスペリエンスを向上させます。
*   **確認プロンプト:** `clear` コマンドで `Confirm.ask` を使用してユーザーに操作の確認を求めるのは、誤操作を防ぐ上で重要です。

### 改善点・考慮事項:
1.  **エラーハンドリングの一貫性:**
    *   `WatchlistManager` のメソッド（例: `add_stock`, `remove_stock`, `get_watchlist`）は、内部で `print` を使用してエラーメッセージを出力し、`True`/`False` や空のリストを返しています。しかし、CLIコマンド側では、これらの戻り値に基づいて `create_error_panel` を表示しています。
    *   **推奨:** `WatchlistManager` 側で `logging` を使用するか、カスタム例外を発生させるように変更し、CLIコマンド側でそれらの例外をキャッチして `create_error_panel` を表示する方が、エラーハンドリングの一貫性が保たれ、デバッグも容易になります。
2.  **`normalize_stock_codes` の冗長な呼び出し:**
    *   `add`, `remove`, `memo`, `move` コマンドで、`click.argument` で受け取った `code` や `codes` を `normalize_stock_codes` で正規化しています。`main.py` のレビューでも指摘しましたが、`validate_stock_code` と `normalize_stock_codes` の連携をより効率的にできる可能性があります。
    *   **推奨:** `validate_stock_code` の中で正規化も行うようにロジックを統合するか、`normalize_stock_codes` が無効なコードをスキップするのではなく、エラーを返すように変更し、CLI側でそのエラーを適切に処理する。
3.  **`watchlist_list` の `memo` 表示の切り捨て:**
    *   `item.get('memo', '')[:20] + '...' if len(item.get('memo', '')) > 20 else item.get('memo', '')` のようにメモを切り捨てていますが、これは表示上の問題であり、元のメモが失われるわけではありません。
    *   **考慮事項:** 長いメモを完全に表示するためのオプションを提供するか、または別のコマンドで全データを表示する機能（例: `watchlist show-memo <code_id>`）を検討しても良いでしょう。
4.  **`watchlist_groups` の効率性:**
    *   `watchlist_groups` コマンドで、各グループの銘柄数を取得するために `manager.get_watchlist(group)` をループ内で呼び出しています。これは、グループの数が多い場合にデータベースへのアクセスが頻繁になり、パフォーマンスに影響を与える可能性があります。
    *   **推奨:** `WatchlistManager` に、各グループの銘柄数を効率的に取得するメソッド（例: `get_group_counts() -> Dict[str, int]`）を追加することを検討してください。
5.  **`watchlist_add` の `memo` のデフォルト値:**
    *   `memo` のデフォルト値が `""` (空文字列) になっています。これは問題ありませんが、ユーザーがメモを指定しなかった場合に、データベースに空文字列が保存されます。
    *   **考慮事項:** もしメモがないことを `None` で表現したい場合は、デフォルト値を `None` に設定し、データベーススキーマもそれに合わせて調整する必要があります。
6.  **`add_watchlist_commands` 関数の位置:**
    *   この関数はファイルの最後に定義されており、`main.py` からインポートされて使用されることを意図しています。
    *   **考慮事項:** この関数は `watchlist_commands.py` の外部からのみ使用されるため、`__all__` に含めるか、または `main.py` 側で直接 `cli.add_command(watchlist)` を行うように変更することも可能です。現在の配置でも機能的には問題ありません。

## 11. `src/day_trade/models/stock.py`

### 良い点:
*   **明確なモデル定義:** `Stock`, `PriceData`, `Trade`, `WatchlistItem`, `Alert` といった主要なエンティティが明確に定義されています。
*   **適切なカラム型と制約:** 各カラムに適切なデータ型（`String`, `Float`, `Integer`, `DateTime`, `Boolean`）と制約（`nullable=False`, `unique=True`）が設定されています。
*   **外部キー制約:** `ForeignKey` を使用してテーブル間のリレーションシップが適切に定義されており、データ整合性が保たれています。
*   **リレーションシップの定義:** `relationship` を使用して関連するモデルへのアクセスが容易になっています。`back_populates` の使用も適切です。
*   **カスケードオプション:** `Stock` モデルの `price_data`, `watchlist_items`, `alerts` リレーションシップに `cascade="all, delete-orphan"` が設定されており、親レコード削除時に子レコードも自動的に削除されるように設定されているのは良い設計です。
*   **インデックスの定義:** `Index` を使用して検索性能を向上させるためのインデックスが適切に定義されています。特に、複合インデックス (`idx_price_stock_datetime`, `idx_trade_stock_datetime`, `idx_watchlist_stock_group`) は検索効率を高めます。
*   **`Trade` モデルの `total_amount` プロパティ:** 取引総額を計算するプロパティがモデル内に定義されており、ビジネスロジックがモデルにカプセル化されています。
*   **`BaseModel` の継承:** 全てのモデルが `BaseModel` を継承しており、共通の機能（例: `id`, `created_at`, `updated_at`）を再利用できる構造になっています。

### 改善点・考慮事項:
1.  **`Stock` モデルの `code` カラムの長さ:**
    *   `String(10)` と定義されています。日本株の証券コードは通常4桁ですが、米国株など他の市場の銘柄コードはこれより長くなる可能性があります（例: ISINコードなど）。
    *   **考慮事項:** 将来的に他の市場の銘柄を扱う可能性がある場合、この長さを再検討するか、バリデーションロジックで対応することを検討してください。
2.  **`PriceData` モデルの `datetime` カラムの `unique=True` の検討:**
    *   `idx_price_stock_datetime` で `stock_code` と `datetime` の複合ユニークインデックスが設定されています。これは、特定の銘柄の特定の時点での価格データは一意であるべきという意図を表しており、適切です。
    *   **考慮事項:** `datetime` カラム単体で `unique=True` を設定する必要はありません。現在の複合インデックスで十分です。
3.  **`Trade` モデルの `trade_type` カラム:**
    *   `String(10)` で `'buy'` または `'sell'` を格納するとコメントされています。
    *   **推奨:** このような固定された選択肢を持つカラムには、SQLAlchemyの `Enum` 型を使用することを検討してください。これにより、データベースレベルでのデータ整合性を強化し、コードの可読性も向上します。
4.  **`WatchlistItem` モデルの `memo` カラムの長さ:**
    *   `String(200)` と定義されています。
    *   **考慮事項:** メモの長さが200文字で十分か、ユーザーの要件を確認してください。もしより長いメモが必要な場合は、`Text` 型（データベースによっては `VARCHAR` の最大長を超える）を検討することもできます。
5.  **`Alert` モデルの `alert_type` カラム:**
    *   `String(20)` で `'price_above'`, `'price_below'`, `'change_percent'` などを格納するとコメントされています。
    *   **推奨:** `Trade` モデルと同様に、`Enum` 型を使用することを検討してください。
6.  **`BaseModel` の `id` カラムの型:**
    *   `BaseModel` の定義が不明ですが、通常 `id` は `Integer` または `UUID` が使用されます。
    *   **考慮事項:** `id` が主キーとして適切に設定されているか、また、自動インクリメントなどの設定が適切に行われているかを確認してください。
7.  **リレーションシップの `lazy` ロード戦略:**
    *   リレーションシップの `lazy` ロード戦略が明示的に指定されていません。デフォルトでは `lazy='select'` となり、関連データが必要になったときに個別のクエリが発行されます。
    *   **考慮事項:** パフォーマンスが重要な場合、特に複数の関連データを一度にロードする必要があるシナリオでは、`lazy='joined'` や `lazy='subquery'`、または `selectinload` などのEager Loading戦略を検討してください。これは、`stock_master.py` や `watchlist.py` で `session.expunge` を使用している点とも関連します。

## 12. `src/day_trade/models/base.py`

### 良い点:
*   **`TimestampMixin` の導入:** `created_at` と `updated_at` カラムを自動的に管理する `TimestampMixin` は、DRY (Don't Repeat Yourself) 原則に則っており、各モデルでの重複定義を避けることができます。`onupdate=datetime.now` の使用も適切です。
*   **`BaseModel` の抽象化:** `__abstract__ = True` を設定することで、`BaseModel` 自体がテーブルとして作成されることを防ぎ、他のモデルがこの基底クラスを継承してテーブルを定義する構造になっています。
*   **自動テーブル名生成:** `@declared_attr` を使用してクラス名から自動的にテーブル名を生成する (`cls.__name__.lower()`) のは、命名規則の一貫性を保つ上で非常に便利です。
*   **`id` カラムの定義:** 全てのモデルに共通の主キー `id` を定義しているのは良いプラクティスです。`primary_key=True` と `index=True` の設定も適切です。
*   **`to_dict` メソッド:** モデルオブジェクトを辞書に変換する汎用的なメソッドは、APIレスポンスの生成やデバッグなど、様々な場面で役立ちます。
*   **`__repr__` メソッド:** オブジェクトの文字列表現を分かりやすく定義しており、デバッグ時にオブジェクトの内容を確認しやすくなります。
*   **責務の分離:** タイムスタンプと基本的なモデルの共通機能を分離して定義しているのは、モジュール設計として優れています。

### 改善点・考慮事項:
1.  **`id` カラムの自動インクリメント:**
    *   `id = Column(Integer, primary_key=True, index=True)` と定義されていますが、SQLiteなどのデータベースでは通常、`Integer` 型の主キーは自動的にインクリメントされます。しかし、他のデータベース（PostgreSQLなど）では明示的に `autoincrement=True` を指定するか、シーケンスを使用する必要があります。
    *   **考慮事項:** 現在SQLiteを使用しているため問題ありませんが、将来的に他のデータベースに移行する可能性がある場合、`autoincrement=True` を明示的に追加することを検討してください。
2.  **`to_dict` メソッドのパフォーマンスと柔軟性:**
    *   `self.__table__.columns` をループして辞書を生成していますが、これはモデルが持つ全てのカラムを対象とします。関連するオブジェクト（リレーションシップ）は含まれません。
    *   **考慮事項:**
        *   もしリレーションシップを含めて辞書化したい場合は、別のメソッド（例: `to_json` や `to_full_dict`）を定義するか、`to_dict` に引数（例: `include_relationships=False`）を追加することを検討してください。
        *   パフォーマンスがクリティカルな場合、特に大量のオブジェクトを辞書化する際には、より効率的な方法（例: `sqlalchemy.orm.query.Query.all()` の結果を直接辞書化する）を検討することもできます。
3.  **`__repr__` メソッドの `to_dict` 呼び出し:**
    *   `__repr__` メソッド内で `self.to_dict()` を呼び出しています。これは、`to_dict` がデータベースアクセスを伴う場合（例えば、遅延ロードされたリレーションシップを強制的にロードする場合）に、予期せぬデータベースクエリを引き起こす可能性があります。現在の `to_dict` はカラムのみを対象としているため問題ありませんが、将来的に `to_dict` の実装が変更される可能性を考慮すると、注意が必要です。
    *   **推奨:** `__repr__` はデバッグ目的で頻繁に呼び出される可能性があるため、可能な限り軽量であるべきです。もし `to_dict` が複雑になる場合、`__repr__` では主要な識別子（例: `id` や `name`）のみを表示するように簡略化することを検討してください。

## 13. `test_cli.py`

### 問題点:
1.  **テストフレームワークの欠如:**
    `test_cli.py` はCLIの動作確認スクリプトであり、テストフレームワークを使用していないため、自動テストとしては不十分です。
2.  **`sys.argv` の直接操作:**
    `sys.argv` を直接操作してCLIコマンドをテストする方法は推奨されません。

### 提案される解決策:
1.  **PytestとClickの `CliRunner` の導入:**
    `pytest` と `click.testing.CliRunner` を使用して、本格的なテストスイートを構築することを推奨します。これにより、テストの構造化、独立性、再現性が向上します。
2.  **テストケースの拡充:**
    各CLIコマンドに対して、正常系、異常系、オプションのテストケースを追加してください。

## 14. `tests/test_stock_fetcher.py`

### 良い点:
*   **Pytestの活用:** `pytest` を使用しており、テストの構造化、フィクスチャの利用、パラメーター化されたテストなど、モダンなPythonテストのプラクティスに従っています。
*   **モックの適切な使用:** `unittest.mock.patch` を使用して `yfinance.Ticker` をモック化しており、外部APIへの依存を排除し、テストの独立性と実行速度を確保しています。
*   **広範なテストカバレッジ:**
    *   `DataCache` クラスの基本的な機能（設定、取得、有効期限、クリア）がテストされています。
    *   `StockFetcher` クラスの主要なメソッド（`_format_symbol`, `get_current_price`, `get_historical_data`, `get_historical_data_range`, `get_realtime_data`, `get_company_info`）がテストされています。
    *   キャッシュの動作（`lru_cache`, `cache_with_ttl`）もテストされています。
    *   入力値の妥当性チェック（`_validate_symbol`, `_validate_period_interval`）がテストされています。
    *   エラーハンドリング（`_is_retryable_error`, `get_current_price_with_errors`）もカバーされています。
*   **カスタム例外のテスト:** 定義されたカスタム例外（`InvalidSymbolError`, `DataNotFoundError`）が適切に発生するかどうかが `pytest.raises` を使用して検証されています。
*   **フィクスチャの活用:** `fetcher` と `mock_ticker_info` フィクスチャを使用することで、テストコードの重複を減らし、可読性を向上させています。
*   **`sys.path.insert`:** テスト実行時にモジュールを正しくインポートするための設定がされています。

### 改善点・考慮事項:
1.  **`test_get_current_price_exception` のアサーション:**
    *   現在、`assert result is None` となっていますが、`StockFetcher` の `_retry_on_error` メソッドは最終的に例外を再発生させるはずです。
    *   **推奨:** `pytest.raises(StockFetcherError)` のように、適切なカスタム例外が再発生することを確認するアサーションに変更すべきです。これにより、エラーハンドリングロジックが期待通りに動作していることをより厳密にテストできます。
2.  **`test_get_current_price_no_data` のアサーション:**
    *   `StockFetcher` の `get_current_price` メソッドは、データが見つからない場合に `DataNotFoundError` を発生させるはずです。
    *   **推奨:** `pytest.raises(DataNotFoundError)` のように、適切なカスタム例外が再発生することを確認するアサーションに変更すべきです。
3.  **`test_get_historical_data_empty` のアサーション:**
    *   `StockFetcher` の `get_historical_data` メソッドは、データが空の場合に `DataNotFoundError` を発生させるはずです。
    *   **推奨:** `pytest.raises(DataNotFoundError)` のように、適切なカスタム例外が再発生することを確認するアサーションに変更すべきです。
4.  **`_retry_on_error` のテストカバレッジ:**
    *   `_retry_on_error` メソッド自体がリトライロジックと指数バックオフを含んでいるため、実際にリトライが複数回行われるシナリオや、リトライ後に成功するシナリオ、最終的にリトライ回数を超えてエラーが再発生するシナリオなどをテストすると、より堅牢性が高まります。
    *   **推奨:** `mock.side_effect` を使用して、最初の数回はエラーを発生させ、その後成功するようなモックを設定し、リトライ回数が期待通りであることを検証するテストケースを追加してください。
5.  **`cache_with_ttl` デコレータのキャッシュキー生成のテスト:**
    *   `stock_fetcher.py` のレビューで指摘したように、キャッシュキーの生成ロジック (`f"{func.__name__}:{str(args)}:{str(sorted(kwargs.items()))}"`) は、引数の順序や型、辞書の順序に依存するため、意図しないキャッシュミスや衝突が発生する可能性があります。
    *   **推奨:** 異なる引数の順序や、同じ内容だが異なる表現の引数（例: `{"a": 1, "b": 2}` と `{"b": 2, "a": 1}`）が同じキャッシュキーを生成するか、または異なるキャッシュキーを生成するかを検証するテストケースを追加してください。
6.  **`_is_retryable_error` と `_handle_error` のテストの網羅性:**
    *   これらのメソッドはエラーメッセージの文字列解析に依存しているため、テストケースで様々なエラーメッセージを試すことで、より堅牢性を高めることができます。
    *   **推奨:** `yfinance` や `requests` が実際に発生させる可能性のある様々なエラーメッセージのパターンをテストケースに追加してください。
7.  **`sys.path.insert` の代替案:**
    *   `sys.path.insert(0, os.path.join(os.path.dirname(__file__), '..', 'src'))` はテスト実行環境に依存する可能性があり、推奨されるプラクティスではありません。
    *   **推奨:** `src` ディレクトリをPythonパッケージとして適切に設定し、`pip install -e .` で編集可能モードでインストールするか、`PYTHONPATH` 環境変数を設定してテストを実行することを検討してください。

## 15. `tests/test_stock_master.py`

### 良い点:
*   **Pytestの活用:** `pytest` を使用しており、テストの構造化、フィクスチャの利用など、モダンなPythonテストのプラクティスに従っています。
*   **テスト用データベースのセットアップ:** `setup_test_db` フィクスチャを使用して、テストごとに独立したインメモリSQLiteデータベースをセットアップし、クリーンな状態を保証しています。これはデータベース関連のテストにおいて非常に重要です。
*   **サンプルデータの提供:** `sample_stocks` フィクスチャにより、テストで使用するデータが明確に定義されています。
*   **主要なCRUD操作のテスト:** `add_stock`, `get_stock_by_code`, `search_stocks_by_name`, `search_stocks_by_sector`, `update_stock`, `delete_stock`, `get_stock_count` といった `StockMasterManager` の主要な機能がテストされています。
*   **重複追加のテスト:** `test_add_duplicate_stock` で、重複する銘柄を追加した場合の挙動がテストされており、既存の銘柄が返されることを確認しています。
*   **`sys.path.insert`:** テスト実行時にモジュールを正しくインポートするための設定がされています。

### 改善点・考慮事項:
1.  **テスト用のヘルパーメソッドの動的な追加:**
    *   ファイルの最後に `_add_helper_methods()` 関数を定義し、`StockMasterManager` クラスにテスト用のメソッドを動的に追加しています。これは、テストコードとプロダクションコードを分離する意図があるかもしれませんが、テストの可読性を損ない、予期せぬ副作用を引き起こす可能性があります。
    *   **推奨:**
        *   テスト対象の `StockMasterManager` クラスに、テストで必要なメソッド（例: `_search_with_db_manager` のような汎用的なクエリ実行メソッド）を直接追加するか、またはテストクラス内でモックやパッチを使用してデータベースセッションを操作する方が、よりクリーンなアプローチです。
        *   もし `StockMasterManager` のメソッドがセッションを引数として受け取るように設計されているのであれば、テストフィクスチャからセッションを渡すだけで済み、このようなヘルパーメソッドは不要になります。
2.  **`test_get_stock_by_code` での `stock_master.__dict__['db_manager'] = db_manager` の直接操作:**
    *   これは非常に危険な操作であり、プロダクションコードの内部状態を直接書き換えるため、テストの信頼性を損ない、デバッグを困難にする可能性があります。
    *   **推奨:** `StockMasterManager` のインスタンスをテストフィクスチャで作成する際に、テスト用の `db_manager` をコンストラクタに渡すか、または `pytest-mock` などのライブラリを使用して `db_manager` をモック化するべきです。
3.  **`StockMasterManager` の `__init__` メソッド:**
    *   `StockMasterManager` の `__init__` は現在 `pass` されていますが、`stock_master.py` のレビューで指摘したように、`StockFetcher` のインスタンスを内部で持っています。
テストでは `StockFetcher` のモック化が必要になる場合があります。
    *   **推奨:** `StockMasterManager` のコンストラクタで `StockFetcher` のインスタンスを受け取れるようにし、テスト時にはモックの `StockFetcher` を渡せるように依存性注入のパターンを適用することを検討してください。
4.  **`fetch_and_update_stock_info` メソッドのテスト:**
    *   `StockMasterManager` には `fetch_and_update_stock_info` という重要なメソッドがありますが、このテストファイルにはそのテストケースがありません。このメソッドは `yfinance` を使用するため、モック化が必要です。
    *   **推奨:** `fetch_and_update_stock_info` のテストケースを追加し、`yfinance.Ticker` を適切にモック化して、銘柄情報の取得と更新が正しく行われることを検証してください。
5.  **エラーパスのテスト:**
    *   `StockMasterManager` のメソッドは、エラー発生時に `None` を返したり、ログを出力したりします。これらのエラーパスが期待通りに動作するかどうかのテストケースが不足しています。
    *   **推奨:** 例えば、データベースへの書き込みが失敗した場合や、存在しない銘柄を更新/削除しようとした場合など、エラーシナリオをテストしてください。
6.  **`sys.path.insert` の代替案:**
    *   `sys.path.insert(0, os.path.join(os.path.dirname(__file__), '..', 'src'))` はテスト実行環境に依存する可能性があり、推奨されるプラクティスではありません。
    *   **推奨:** `src` ディレクトリをPythonパッケージとして適切に設定し、`pip install -e .` で編集可能モードでインストールするか、`PYTHONPATH` 環境変数を設定してテストを実行することを検討してください。
