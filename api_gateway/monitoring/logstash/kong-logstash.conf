# Logstash Configuration for Kong API Gateway
# Day Trade ML System - API Gateway Log Processing

input {
  # Kong Access Logs
  file {
    path => "/var/log/kong/access.log"
    start_position => "beginning"
    codec => "json"
    type => "kong-access"
    tags => ["kong", "access", "api-gateway"]
  }

  # Kong Error Logs
  file {
    path => "/var/log/kong/error.log"
    start_position => "beginning"
    type => "kong-error"
    tags => ["kong", "error", "api-gateway"]
  }

  # Kong Admin Logs
  file {
    path => "/var/log/kong/admin_access.log"
    start_position => "beginning"
    codec => "json"
    type => "kong-admin"
    tags => ["kong", "admin", "api-gateway"]
  }

  # Syslog Input (for remote logs)
  syslog {
    port => 5514
    type => "syslog"
    tags => ["kong", "syslog", "remote"]
  }

  # HTTP Input (for webhook logs)
  http {
    port => 8080
    type => "webhook"
    tags => ["kong", "webhook", "api-gateway"]
  }

  # Beats Input (for Filebeat integration)
  beats {
    port => 5044
    type => "beats"
    tags => ["kong", "beats", "api-gateway"]
  }
}

filter {
  # Kong Access Log Processing
  if [type] == "kong-access" {
    # Parse timestamp
    date {
      match => [ "started_at", "UNIX_MS" ]
      target => "@timestamp"
    }

    # Extract request information
    mutate {
      add_field => {
        "service_name" => "%{[service][name]}"
        "route_name" => "%{[route][name]}"
        "consumer_id" => "%{[consumer][id]}"
        "client_ip" => "%{[client_ip]}"
        "request_method" => "%{[request][method]}"
        "request_uri" => "%{[request][uri]}"
        "request_size" => "%{[request][size]}"
        "response_status" => "%{[response][status]}"
        "response_size" => "%{[response][size]}"
        "latency_request" => "%{[latencies][request]}"
        "latency_kong" => "%{[latencies][kong]}"
        "latency_proxy" => "%{[latencies][proxy]}"
      }
    }

    # Convert latencies to numbers
    mutate {
      convert => {
        "latency_request" => "integer"
        "latency_kong" => "integer"
        "latency_proxy" => "integer"
        "request_size" => "integer"
        "response_size" => "integer"
        "response_status" => "integer"
      }
    }

    # Add performance categorization
    if [latency_request] {
      if [latency_request] < 100 {
        mutate { add_field => { "performance_category" => "fast" } }
      } else if [latency_request] < 500 {
        mutate { add_field => { "performance_category" => "normal" } }
      } else if [latency_request] < 1000 {
        mutate { add_field => { "performance_category" => "slow" } }
      } else {
        mutate { add_field => { "performance_category" => "very_slow" } }
      }
    }

    # Add status categorization
    if [response_status] {
      if [response_status] >= 200 and [response_status] < 300 {
        mutate { add_field => { "status_category" => "success" } }
      } else if [response_status] >= 300 and [response_status] < 400 {
        mutate { add_field => { "status_category" => "redirect" } }
      } else if [response_status] >= 400 and [response_status] < 500 {
        mutate { add_field => { "status_category" => "client_error" } }
      } else if [response_status] >= 500 {
        mutate { add_field => { "status_category" => "server_error" } }
      }
    }

    # GeoIP enrichment (if client_ip is available)
    if [client_ip] {
      geoip {
        source => "client_ip"
        target => "geoip"
      }
    }

    # User-Agent parsing
    if [request][headers][user-agent] {
      useragent {
        source => "[request][headers][user-agent]"
        target => "user_agent"
      }
    }
  }

  # Kong Error Log Processing
  if [type] == "kong-error" {
    # Parse timestamp from error logs
    grok {
      match => {
        "message" => "%{TIMESTAMP_ISO8601:timestamp} \[%{DATA:log_level}\] %{GREEDYDATA:error_message}"
      }
    }

    date {
      match => [ "timestamp", "ISO8601" ]
      target => "@timestamp"
    }

    # Categorize error levels
    if [log_level] {
      if [log_level] == "error" or [log_level] == "crit" or [log_level] == "alert" or [log_level] == "emerg" {
        mutate { add_field => { "severity" => "high" } }
      } else if [log_level] == "warn" {
        mutate { add_field => { "severity" => "medium" } }
      } else {
        mutate { add_field => { "severity" => "low" } }
      }
    }
  }

  # Add common fields
  mutate {
    add_field => {
      "environment" => "production"
      "application" => "day-trade-ml"
      "component" => "api-gateway"
      "log_source" => "kong"
    }
  }

  # Remove unnecessary fields
  mutate {
    remove_field => [ "host", "path" ]
  }
}

output {
  # Elasticsearch Output
  elasticsearch {
    hosts => ["elasticsearch:9200"]
    index => "kong-logs-%{+YYYY.MM.dd}"
    template_name => "kong-logs"
    template_pattern => "kong-logs-*"
    template => {
      "mappings" => {
        "properties" => {
          "@timestamp" => { "type" => "date" }
          "service_name" => { "type" => "keyword" }
          "route_name" => { "type" => "keyword" }
          "client_ip" => { "type" => "ip" }
          "request_method" => { "type" => "keyword" }
          "request_uri" => { "type" => "text" }
          "response_status" => { "type" => "integer" }
          "latency_request" => { "type" => "integer" }
          "latency_kong" => { "type" => "integer" }
          "latency_proxy" => { "type" => "integer" }
          "performance_category" => { "type" => "keyword" }
          "status_category" => { "type" => "keyword" }
          "severity" => { "type" => "keyword" }
          "geoip" => {
            "properties" => {
              "location" => { "type" => "geo_point" }
              "country_name" => { "type" => "keyword" }
              "city_name" => { "type" => "keyword" }
            }
          }
        }
      }
    }
  }

  # File Output (for backup)
  file {
    path => "/var/log/logstash/kong-processed-%{+YYYY-MM-dd}.log"
    codec => json_lines
  }

  # Conditional outputs based on log type and severity

  # High-severity errors to immediate alerting
  if [severity] == "high" or [status_category] == "server_error" {
    http {
      url => "http://notification-service:8004/api/v1/notifications/send"
      http_method => "post"
      content_type => "application/json"
      mapping => {
        "type" => "alert"
        "message" => "Kong API Gateway Error: %{message}"
        "severity" => "%{severity}"
        "timestamp" => "%{@timestamp}"
        "service" => "%{service_name}"
        "status" => "%{response_status}"
      }
    }
  }

  # Performance issues to monitoring
  if [performance_category] == "very_slow" {
    kafka {
      topic_id => "performance-alerts"
      bootstrap_servers => "kafka:9092"
      codec => json
    }
  }

  # Debug output (remove in production)
  # stdout {
  #   codec => rubydebug
  # }
}