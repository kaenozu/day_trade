#!/usr/bin/env python3
"""
品質ゲートシステム - レポート生成

品質評価結果から人間にとって読みやすい
レポートを生成するモジュール。CI/CD用の
マークダウン形式やJSON形式での出力を提供する。
"""

import ast
from typing import Any, Dict, List

from .enums import QualityLevel
from .types import FileQualityReport, QualityResult


class QualityReportGenerator:
    """品質レポート生成システム
    
    品質評価の結果を各種形式でレポート化し、
    CI/CDパイプラインや開発者に分かりやすい
    形式で情報を提供する。
    """

    def generate_ci_report(self, report: Dict[str, Any]) -> str:
        """CI/CD用レポートを生成
        
        品質評価結果をCI/CDパイプライン用の
        マークダウン形式レポートとして生成する。
        
        Args:
            report: 品質評価結果の辞書
            
        Returns:
            マークダウン形式のレポート文字列
        """
        lines = [
            "# [品質] Quality Gate Report",
            "",
            f"**Overall Score**: {report['overall_score']:.1f}/100 ({report['overall_level'].upper()})",
            f"**Gates Passed**: {report['gates_passed']}/{report['gates_total']}",
            f"**Timestamp**: {report['timestamp']}",
            "",
            "## [状況] Quality Gates Status",
            "",
        ]

        for result in report["gate_results"]:
            status_mark = "[PASS]" if result.passed else "[FAIL]"
            level_mark = {
                QualityLevel.EXCELLENT: "[優秀]",
                QualityLevel.GOOD: "[良好]",
                QualityLevel.ACCEPTABLE: "[許容]",
                QualityLevel.NEEDS_IMPROVEMENT: "[要改善]",
                QualityLevel.CRITICAL: "[危険]",
            }.get(result.level, "[不明]")

            lines.extend(
                [
                    f"### {status_mark} {result.gate_id.replace('_', ' ').title()}",
                    f"- **Value**: {result.value:.1f}",
                    f"- **Level**: {level_mark} {result.level.value}",
                    f"- **Status**: {'PASS' if result.passed else 'FAIL'}",
                    f"- **Message**: {result.message}",
                    "",
                ]
            )

        if report["recommendations"]:
            lines.extend(["## [推奨] Recommendations", ""])
            for i, rec in enumerate(report["recommendations"], 1):
                lines.append(f"{i}. {rec}")
            lines.append("")

        lines.extend(
            [
                "## [概要] Summary",
                f"- Excellent Gates: {report['summary']['excellent_gates']}",
                f"- Good Gates: {report['summary']['good_gates']}",
                f"- Acceptable Gates: {report['summary']['acceptable_gates']}",
                f"- Critical Gates: {report['summary']['critical_gates']}",
                "",
                "---",
                "*Generated by Advanced Quality Gate System*",
            ]
        )

        return "\n".join(lines)

    def generate_detailed_report(self, report: Dict[str, Any]) -> str:
        """詳細レポートを生成
        
        開発者向けの詳細なマークダウンレポートを生成する。
        ファイル別の詳細情報や推奨事項を含む。
        
        Args:
            report: 品質評価結果の辞書
            
        Returns:
            詳細マークダウンレポート
        """
        lines = [
            "# 品質ゲート詳細レポート",
            "",
            f"**生成日時**: {report['timestamp']}",
            f"**総合スコア**: {report['overall_score']:.1f}/100",
            f"**品質レベル**: {report['overall_level']}",
            "",
        ]

        # 総合評価セクション
        lines.extend([
            "## 総合評価",
            "",
            f"- ✅ 合格ゲート: {report['gates_passed']}個",
            f"- ❌ 不合格ゲート: {report['gates_total'] - report['gates_passed']}個",
            f"- ⭐ 優秀: {report['summary']['excellent_gates']}個",
            f"- ✅ 良好: {report['summary']['good_gates']}個",
            f"- ⚠️ 許容: {report['summary']['acceptable_gates']}個",
            f"- ❌ 危険: {report['summary']['critical_gates']}個",
            "",
        ])

        # 各ゲートの詳細
        lines.extend(["## 品質ゲート詳細", ""])
        
        for result in report["gate_results"]:
            status_icon = "✅" if result.passed else "❌"
            level_icon = {
                QualityLevel.EXCELLENT: "⭐",
                QualityLevel.GOOD: "✅",
                QualityLevel.ACCEPTABLE: "⚠️",
                QualityLevel.NEEDS_IMPROVEMENT: "⚠️",
                QualityLevel.CRITICAL: "❌",
            }.get(result.level, "❓")

            lines.extend([
                f"### {status_icon} {result.gate_id.replace('_', ' ').title()}",
                "",
                f"**評価値**: {result.value:.1f}",
                f"**レベル**: {level_icon} {result.level.value}",
                f"**判定**: {'合格' if result.passed else '不合格'}",
                f"**メッセージ**: {result.message}",
                "",
            ])

            # 推奨事項
            if result.recommendations:
                lines.extend(["**改善提案**:", ""])
                for rec in result.recommendations:
                    lines.append(f"- {rec}")
                lines.append("")

        # ファイル別品質情報
        if "file_reports" in report and report["file_reports"]:
            lines.extend(["## ファイル別品質情報", ""])
            
            # 低品質ファイルのトップ10
            file_reports = sorted(
                report["file_reports"], 
                key=lambda x: x.maintainability_index
            )[:10]
            
            lines.extend([
                "### 改善が必要なファイル（保守性指標順）",
                "",
                "| ファイル | 複雑度 | 保守性 | レベル |",
                "|----------|--------|--------|--------|",
            ])
            
            for file_report in file_reports:
                level_icon = {
                    QualityLevel.EXCELLENT: "⭐",
                    QualityLevel.GOOD: "✅",
                    QualityLevel.ACCEPTABLE: "⚠️",
                    QualityLevel.NEEDS_IMPROVEMENT: "⚠️",
                    QualityLevel.CRITICAL: "❌",
                }.get(file_report.quality_level, "❓")
                
                filename = file_report.file_path.split("/")[-1]
                lines.append(
                    f"| {filename} | {file_report.complexity_score:.1f} | "
                    f"{file_report.maintainability_index:.1f} | {level_icon} |"
                )
            
            lines.append("")

        # 推奨事項セクション
        if report["recommendations"]:
            lines.extend(["## 改善推奨事項", ""])
            for i, rec in enumerate(report["recommendations"], 1):
                lines.append(f"{i}. {rec}")
            lines.append("")

        return "\n".join(lines)

    def collect_file_quality_reports(
        self, complexity_analyzer, project_root
    ) -> List[FileQualityReport]:
        """ファイル別品質レポートを収集
        
        プロジェクト内の各ファイルについて品質指標を計算し、
        FileQualityReportオブジェクトのリストを生成する。
        
        Args:
            complexity_analyzer: 複雑度解析器
            project_root: プロジェクトルートパス
            
        Returns:
            ファイル品質レポートのリスト
        """
        file_reports = []
        python_files = list(project_root.glob("src/**/*.py"))

        for file_path in python_files:
            if "test" in str(file_path).lower() or "example" in str(file_path).lower():
                continue

            complexity_data = complexity_analyzer.analyze_file(str(file_path))

            if "error" not in complexity_data:
                quality_level = QualityLevel.GOOD  # デフォルト

                # 品質レベル判定
                complexity = complexity_data["mccabe_complexity"]
                maintainability = complexity_data["maintainability_index"]

                if complexity > 20 or maintainability < 30:
                    quality_level = QualityLevel.CRITICAL
                elif complexity > 15 or maintainability < 50:
                    quality_level = QualityLevel.NEEDS_IMPROVEMENT
                elif complexity > 10 or maintainability < 70:
                    quality_level = QualityLevel.ACCEPTABLE

                file_report = FileQualityReport(
                    file_path=str(file_path),
                    lines_of_code=complexity_data["lines_of_code"],
                    complexity_score=complexity,
                    maintainability_index=maintainability,
                    type_coverage=self._calculate_type_coverage(file_path),
                    documentation_coverage=self._calculate_doc_coverage(file_path),
                    quality_level=quality_level,
                )

                file_reports.append(file_report)

        return file_reports

    def _calculate_type_coverage(self, file_path) -> float:
        """型アノテーションカバレッジ計算"""
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                content = f.read()

            tree = ast.parse(content)
            total_functions = 0
            typed_functions = 0

            for node in ast.walk(tree):
                if isinstance(node, (ast.FunctionDef, ast.AsyncFunctionDef)):
                    total_functions += 1

                    # 戻り値の型アノテーションチェック
                    has_return_annotation = node.returns is not None

                    # 引数の型アノテーションチェック
                    has_arg_annotations = all(
                        arg.annotation is not None for arg in node.args.args
                        if arg.arg != 'self'  # selfは除外
                    )

                    if has_return_annotation and has_arg_annotations:
                        typed_functions += 1

            # カバレッジ計算
            if total_functions == 0:
                return 100.0  # 関数がない場合は100%

            coverage = (typed_functions / total_functions) * 100
            return round(coverage, 1)

        except Exception:
            return 0.0

    def _calculate_doc_coverage(self, file_path) -> float:
        """ドキュメントカバレッジ計算"""
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                content = f.read()

            tree = ast.parse(content)
            total_items = 0
            documented_items = 0

            for node in ast.walk(tree):
                if isinstance(node, (ast.FunctionDef, ast.AsyncFunctionDef, ast.ClassDef)):
                    total_items += 1

                    # docstringの存在チェック
                    if (node.body and
                        isinstance(node.body[0], ast.Expr) and
                        isinstance(node.body[0].value, ast.Constant) and
                        isinstance(node.body[0].value.value, str)):
                        documented_items += 1

            # カバレッジ計算
            if total_items == 0:
                return 100.0  # アイテムがない場合は100%

            coverage = (documented_items / total_items) * 100
            return round(coverage, 1)

        except Exception:
            return 0.0