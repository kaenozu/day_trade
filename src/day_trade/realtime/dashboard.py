#!/usr/bin/env python3
"""
Next-Gen AI Trading Engine - „É™„Ç¢„É´„Çø„Ç§„É†Web„ÉÄ„ÉÉ„Ç∑„É•„Éú„Éº„Éâ
Áµ±ÂêàÁõ£Ë¶ñ„ÉªÂà∂Âæ°Web„Ç§„É≥„Çø„Éº„Éï„Çß„Éº„Çπ

AI‰∫àÊ∏¨„ÉªÂ∏ÇÂ†¥„Éá„Éº„Çø„Éª„Ç∑„Çπ„ÉÜ„É†Áä∂Ê≥Å„ÅÆ„É™„Ç¢„É´„Çø„Ç§„É†ÂèØË¶ñÂåñ
"""

import asyncio
import json
import warnings
from datetime import datetime
from pathlib import Path
from typing import Any, Dict, List, Optional

import uvicorn

# Web „Éï„É¨„Éº„É†„ÉØ„Éº„ÇØ
from fastapi import FastAPI, Request, WebSocket, WebSocketDisconnect
from fastapi.responses import HTMLResponse, JSONResponse
from fastapi.staticfiles import StaticFiles
from fastapi.templating import Jinja2Templates

# „Éó„É≠„Ç∏„Çß„ÇØ„ÉàÂÜÖ„Ç§„É≥„Éù„Éº„Éà
from ..utils.logging_config import get_context_logger
from .alert_system import AlertManager
from .live_prediction_engine import LivePredictionEngine
from .performance_monitor import RealTimePerformanceMonitor
from .websocket_stream import RealTimeStreamManager

logger = get_context_logger(__name__)
warnings.filterwarnings("ignore", category=FutureWarning)


class DashboardManager:
    """„ÉÄ„ÉÉ„Ç∑„É•„Éú„Éº„ÉâÁÆ°ÁêÜ„Ç∑„Çπ„ÉÜ„É†"""

    def __init__(self):
        # FastAPI „Ç¢„Éó„É™„Ç±„Éº„Ç∑„Éß„É≥
        self.app = FastAPI(title="Next-Gen AI Trading Dashboard", version="1.0")

        # WebSocketÊé•Á∂öÁÆ°ÁêÜ
        self.active_connections: List[WebSocket] = []

        # „Ç∑„Çπ„ÉÜ„É†„Ç≥„É≥„Éù„Éº„Éç„É≥„ÉàÔºàÂ§ñÈÉ®„Åã„ÇâÊ≥®ÂÖ•Ôºâ
        self.prediction_engine: Optional[LivePredictionEngine] = None
        self.performance_monitor: Optional[RealTimePerformanceMonitor] = None
        self.alert_manager: Optional[AlertManager] = None
        self.stream_manager: Optional[RealTimeStreamManager] = None

        # „ÉÄ„ÉÉ„Ç∑„É•„Éú„Éº„Éâ„Éá„Éº„Çø
        self.dashboard_data = {
            "system_status": "Starting",
            "last_update": datetime.now().isoformat(),
            "active_predictions": [],
            "performance_metrics": {},
            "recent_alerts": [],
            "market_data": {},
        }

        # Êõ¥Êñ∞„Çø„Çπ„ÇØ
        self.update_task: Optional[asyncio.Task] = None
        self.is_running = False

        # „É´„Éº„ÉàË®≠ÂÆö
        self._setup_routes()
        self._setup_static_files()

        logger.info("Dashboard Manager initialized")

    def _setup_routes(self):
        """„É´„Éº„ÉàË®≠ÂÆö"""

        @self.app.get("/", response_class=HTMLResponse)
        async def dashboard_home(request: Request):
            """„É°„Ç§„É≥„ÉÄ„ÉÉ„Ç∑„É•„Éú„Éº„Éâ"""
            return await self._render_dashboard(request)

        @self.app.get("/api/status")
        async def get_system_status():
            """„Ç∑„Çπ„ÉÜ„É†Áä∂Ê≥ÅAPI"""
            return JSONResponse(self._get_system_status())

        @self.app.get("/api/predictions")
        async def get_predictions():
            """‰∫àÊ∏¨ÁµêÊûúAPI"""
            return JSONResponse(self._get_recent_predictions())

        @self.app.get("/api/performance")
        async def get_performance():
            """„Éë„Éï„Ç©„Éº„Éû„É≥„ÇπÊåáÊ®ôAPI"""
            return JSONResponse(self._get_performance_metrics())

        @self.app.get("/api/alerts")
        async def get_alerts():
            """„Ç¢„É©„Éº„Éà‰∏ÄË¶ßAPI"""
            return JSONResponse(self._get_recent_alerts())

        @self.app.get("/api/market")
        async def get_market_data():
            """Â∏ÇÂ†¥„Éá„Éº„ÇøAPI"""
            return JSONResponse(self._get_market_data())

        @self.app.websocket("/ws")
        async def websocket_endpoint(websocket: WebSocket):
            """WebSocket „Ç®„É≥„Éâ„Éù„Ç§„É≥„Éà"""
            await self._handle_websocket(websocket)

        @self.app.post("/api/alerts/{alert_id}/acknowledge")
        async def acknowledge_alert(alert_id: str):
            """„Ç¢„É©„Éº„ÉàÁ¢∫Ë™çAPI"""
            if self.alert_manager:
                success = self.alert_manager.acknowledge_alert(alert_id)
                return {"success": success, "alert_id": alert_id}
            return {"success": False, "error": "Alert manager not available"}

        @self.app.post("/api/system/restart")
        async def restart_system():
            """„Ç∑„Çπ„ÉÜ„É†ÂÜçËµ∑ÂãïAPI"""
            try:
                await self._restart_components()
                return {"success": True, "message": "System restart initiated"}
            except Exception as e:
                return {"success": False, "error": str(e)}

    def _setup_static_files(self):
        """ÈùôÁöÑ„Éï„Ç°„Ç§„É´Ë®≠ÂÆö"""

        # ÈùôÁöÑ„Éï„Ç°„Ç§„É´„Éá„Ç£„É¨„ÇØ„Éà„É™‰ΩúÊàê
        static_dir = Path("static")
        static_dir.mkdir(exist_ok=True)

        # „ÉÜ„É≥„Éó„É¨„Éº„Éà„Éá„Ç£„É¨„ÇØ„Éà„É™‰ΩúÊàê
        templates_dir = Path("templates")
        templates_dir.mkdir(exist_ok=True)

        # Jinja2 „ÉÜ„É≥„Éó„É¨„Éº„ÉàË®≠ÂÆö
        self.templates = Jinja2Templates(directory="templates")

        # ÈùôÁöÑ„Éï„Ç°„Ç§„É´„Éû„Ç¶„É≥„Éà
        self.app.mount("/static", StaticFiles(directory="static"), name="static")

    async def _render_dashboard(self, request: Request) -> HTMLResponse:
        """„ÉÄ„ÉÉ„Ç∑„É•„Éú„Éº„ÉâHTMLÊèèÁîª"""

        dashboard_html = """
        <!DOCTYPE html>
        <html lang="ja">
        <head>
            <meta charset="UTF-8">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
            <title>Next-Gen AI Trading Dashboard</title>
            <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
            <script src="https://cdn.tailwindcss.com"></script>
            <style>
                .status-healthy { color: #10B981; }
                .status-warning { color: #F59E0B; }
                .status-critical { color: #EF4444; }
                .metric-card {
                    background: linear-gradient(145deg, #f0f9ff, #e0f2fe);
                    border: 1px solid #e5e7eb;
                    border-radius: 0.5rem;
                    padding: 1.5rem;
                    margin-bottom: 1rem;
                    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
                }
                .prediction-card {
                    background: linear-gradient(145deg, #fef3c7, #fbbf24);
                    color: #92400e;
                }
                .alert-card {
                    background: linear-gradient(145deg, #fee2e2, #fca5a5);
                    color: #991b1b;
                }
                .chart-container {
                    position: relative;
                    height: 300px;
                    margin: 1rem 0;
                }
            </style>
        </head>
        <body class="bg-gray-100">
            <div class="container mx-auto px-4 py-6">

                <!-- „Éò„ÉÉ„ÉÄ„Éº -->
                <header class="mb-8">
                    <h1 class="text-4xl font-bold text-gray-800 mb-2">
                        ü§ñ Next-Gen AI Trading Dashboard
                    </h1>
                    <div class="flex items-center space-x-4">
                        <div id="systemStatus" class="status-healthy">
                            ‚óè System Active
                        </div>
                        <div id="lastUpdate" class="text-gray-600">
                            Last Update: Loading...
                        </div>
                    </div>
                </header>

                <!-- „É°„Ç§„É≥„ÉÄ„ÉÉ„Ç∑„É•„Éú„Éº„Éâ -->
                <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">

                    <!-- „Ç∑„Çπ„ÉÜ„É†Áä∂Ê≥Å -->
                    <div class="metric-card">
                        <h3 class="text-xl font-semibold mb-4">üìä System Status</h3>
                        <div id="systemMetrics">
                            <div class="mb-2">CPU: <span id="cpuUsage">--</span>%</div>
                            <div class="mb-2">Memory: <span id="memoryUsage">--</span>%</div>
                            <div class="mb-2">Active Tasks: <span id="activeTasks">--</span></div>
                        </div>
                    </div>

                    <!-- AI ‰∫àÊ∏¨ -->
                    <div class="prediction-card metric-card">
                        <h3 class="text-xl font-semibold mb-4">üéØ AI Predictions</h3>
                        <div id="predictionMetrics">
                            <div class="mb-2">Total: <span id="totalPredictions">--</span></div>
                            <div class="mb-2">Success Rate: <span id="successRate">--</span>%</div>
                            <div class="mb-2">Avg Latency: <span id="avgLatency">--</span>ms</div>
                        </div>
                    </div>

                    <!-- „Ç¢„É©„Éº„Éà -->
                    <div class="alert-card metric-card">
                        <h3 class="text-xl font-semibold mb-4">üö® Active Alerts</h3>
                        <div id="alertMetrics">
                            <div class="mb-2">Active: <span id="activeAlerts">--</span></div>
                            <div class="mb-2">Unread: <span id="unreadAlerts">--</span></div>
                            <div class="mb-2">Today: <span id="todayAlerts">--</span></div>
                        </div>
                    </div>

                </div>

                <!-- „ÉÅ„É£„Éº„Éà„Çª„ÇØ„Ç∑„Éß„É≥ -->
                <div class="grid grid-cols-1 lg:grid-cols-2 gap-6 mt-8">

                    <!-- ‰∫àÊ∏¨„Éë„Éï„Ç©„Éº„Éû„É≥„Çπ „ÉÅ„É£„Éº„Éà -->
                    <div class="metric-card">
                        <h3 class="text-xl font-semibold mb-4">üìà Prediction Performance</h3>
                        <div class="chart-container">
                            <canvas id="performanceChart"></canvas>
                        </div>
                    </div>

                    <!-- „Ç∑„Çπ„ÉÜ„É†„É°„Éà„É™„ÇØ„Çπ „ÉÅ„É£„Éº„Éà -->
                    <div class="metric-card">
                        <h3 class="text-xl font-semibold mb-4">‚ö° System Metrics</h3>
                        <div class="chart-container">
                            <canvas id="systemChart"></canvas>
                        </div>
                    </div>

                </div>

                <!-- ÊúÄËøë„ÅÆ‰∫àÊ∏¨ÁµêÊûú -->
                <div class="metric-card mt-8">
                    <h3 class="text-xl font-semibold mb-4">üîÆ Recent Predictions</h3>
                    <div id="recentPredictions" class="overflow-x-auto">
                        <table class="min-w-full table-auto">
                            <thead>
                                <tr class="bg-gray-50">
                                    <th class="px-4 py-2">Time</th>
                                    <th class="px-4 py-2">Symbol</th>
                                    <th class="px-4 py-2">Action</th>
                                    <th class="px-4 py-2">Confidence</th>
                                    <th class="px-4 py-2">Target Price</th>
                                </tr>
                            </thead>
                            <tbody id="predictionsTableBody">
                                <tr><td colspan="5" class="text-center py-4">Loading...</td></tr>
                            </tbody>
                        </table>
                    </div>
                </div>

                <!-- „Ç¢„É©„Éº„ÉàÂ±•Ê≠¥ -->
                <div class="metric-card mt-8">
                    <h3 class="text-xl font-semibold mb-4">üîî Recent Alerts</h3>
                    <div id="recentAlertsContainer">
                        Loading alerts...
                    </div>
                </div>

            </div>

            <script>
                // WebSocket Êé•Á∂ö
                const ws = new WebSocket(`ws://${window.location.host}/ws`);

                // Chart.js Ë®≠ÂÆö
                let performanceChart, systemChart;

                // WebSocket „É°„ÉÉ„Çª„Éº„Ç∏Âá¶ÁêÜ
                ws.onmessage = function(event) {
                    const data = JSON.parse(event.data);
                    updateDashboard(data);
                };

                ws.onopen = function() {
                    console.log('WebSocket connected');
                };

                ws.onerror = function(error) {
                    console.error('WebSocket error:', error);
                    document.getElementById('systemStatus').className = 'status-critical';
                    document.getElementById('systemStatus').textContent = '‚óè Connection Error';
                };

                // „ÉÄ„ÉÉ„Ç∑„É•„Éú„Éº„ÉâÊõ¥Êñ∞
                function updateDashboard(data) {
                    // „Ç∑„Çπ„ÉÜ„É†Áä∂Ê≥ÅÊõ¥Êñ∞
                    updateSystemStatus(data.system || {});

                    // AI‰∫àÊ∏¨Êõ¥Êñ∞
                    updatePredictions(data.ai || {});

                    // „Ç¢„É©„Éº„ÉàÊõ¥Êñ∞
                    updateAlerts(data.alerts || []);

                    // ÊúÄÁµÇÊõ¥Êñ∞ÊôÇÂàª
                    document.getElementById('lastUpdate').textContent =
                        `Last Update: ${new Date(data.timestamp).toLocaleTimeString()}`;

                    // „ÉÅ„É£„Éº„ÉàÊõ¥Êñ∞
                    updateCharts(data);
                }

                function updateSystemStatus(system) {
                    document.getElementById('cpuUsage').textContent =
                        Math.round(system.cpu_percent || 0);
                    document.getElementById('memoryUsage').textContent =
                        Math.round(system.memory_percent || 0);
                    document.getElementById('activeTasks').textContent =
                        system.active_tasks || 0;

                    // „Çπ„ÉÜ„Éº„Çø„ÇπËâ≤Êõ¥Êñ∞
                    const status = system.status || 'unknown';
                    const statusElement = document.getElementById('systemStatus');
                    statusElement.className = `status-${status}`;
                    statusElement.textContent = `‚óè System ${status.charAt(0).toUpperCase() + status.slice(1)}`;
                }

                function updatePredictions(ai) {
                    document.getElementById('totalPredictions').textContent =
                        ai.total_predictions || 0;
                    document.getElementById('successRate').textContent =
                        Math.round((ai.success_rate || 0) * 100);
                    document.getElementById('avgLatency').textContent =
                        Math.round(ai.average_latency || 0);
                }

                function updateAlerts(alerts) {
                    const activeCount = alerts.filter(a => !a.resolved).length;
                    const unreadCount = alerts.filter(a => !a.acknowledged).length;
                    const todayCount = alerts.filter(a => {
                        const alertDate = new Date(a.timestamp);
                        const today = new Date();
                        return alertDate.toDateString() === today.toDateString();
                    }).length;

                    document.getElementById('activeAlerts').textContent = activeCount;
                    document.getElementById('unreadAlerts').textContent = unreadCount;
                    document.getElementById('todayAlerts').textContent = todayCount;
                }

                function updateCharts(data) {
                    // „ÉÅ„É£„Éº„ÉàÊõ¥Êñ∞ÂÆüË£ÖÔºàÁ∞°Áï•ÂåñÔºâ
                    // ÂÆüÈöõ„ÅÆÂÆüË£Ö„Åß„ÅØ„É™„Ç¢„É´„Çø„Ç§„É†„Éá„Éº„Çø„Çí‰ΩøÁî®
                }

                // ÂàùÊúüÂåñ
                document.addEventListener('DOMContentLoaded', function() {
                    // Chart.jsÂàùÊúüÂåñ
                    initializeCharts();

                    // ÂÆöÊúüÁöÑ„Å™„Éá„Éº„ÇøÂèñÂæó
                    setInterval(fetchDashboardData, 5000);

                    // ÂàùÂõû„Éá„Éº„ÇøÂèñÂæó
                    fetchDashboardData();
                });

                function initializeCharts() {
                    // „Éë„Éï„Ç©„Éº„Éû„É≥„Çπ „ÉÅ„É£„Éº„Éà
                    const perfCtx = document.getElementById('performanceChart').getContext('2d');
                    performanceChart = new Chart(perfCtx, {
                        type: 'line',
                        data: {
                            labels: [],
                            datasets: [{
                                label: 'Success Rate',
                                data: [],
                                borderColor: '#10B981',
                                backgroundColor: 'rgba(16, 185, 129, 0.1)'
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            scales: {
                                y: { beginAtZero: true, max: 100 }
                            }
                        }
                    });

                    // „Ç∑„Çπ„ÉÜ„É†„É°„Éà„É™„ÇØ„Çπ „ÉÅ„É£„Éº„Éà
                    const sysCtx = document.getElementById('systemChart').getContext('2d');
                    systemChart = new Chart(sysCtx, {
                        type: 'doughnut',
                        data: {
                            labels: ['CPU', 'Memory', 'Available'],
                            datasets: [{
                                data: [0, 0, 100],
                                backgroundColor: ['#F59E0B', '#EF4444', '#10B981']
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false
                        }
                    });
                }

                async function fetchDashboardData() {
                    try {
                        const response = await fetch('/api/status');
                        const data = await response.json();
                        updateDashboard(data);
                    } catch (error) {
                        console.error('Failed to fetch dashboard data:', error);
                    }
                }

            </script>
        </body>
        </html>
        """

        return HTMLResponse(content=dashboard_html)

    async def _handle_websocket(self, websocket: WebSocket):
        """WebSocketÊé•Á∂öÂá¶ÁêÜ"""

        await websocket.accept()
        self.active_connections.append(websocket)

        logger.info(
            f"WebSocket connected. Active connections: {len(self.active_connections)}"
        )

        try:
            while True:
                # „ÇØ„É©„Ç§„Ç¢„É≥„Éà„Åã„Çâ„ÅÆ„É°„ÉÉ„Çª„Éº„Ç∏ÂæÖÊ©ü
                data = await websocket.receive_text()

                # „É°„ÉÉ„Çª„Éº„Ç∏Âá¶ÁêÜÔºàÂøÖË¶Å„Å´Âøú„Åò„Å¶Ôºâ
                logger.debug(f"Received WebSocket message: {data}")

        except WebSocketDisconnect:
            self.active_connections.remove(websocket)
            logger.info(
                f"WebSocket disconnected. Active connections: {len(self.active_connections)}"
            )

    async def broadcast_update(self, data: Dict[str, Any]):
        """WebSocket „Éñ„É≠„Éº„Éâ„Ç≠„É£„Çπ„Éà"""

        if not self.active_connections:
            return

        message = json.dumps(data)

        # ÁÑ°Âäπ„Å™Êé•Á∂ö„ÇíÂâäÈô§„Åô„Çã„Åü„ÇÅ„ÅÆ„É™„Çπ„Éà
        invalid_connections = []

        for connection in self.active_connections:
            try:
                await connection.send_text(message)
            except Exception as e:
                logger.warning(f"Failed to send WebSocket message: {e}")
                invalid_connections.append(connection)

        # ÁÑ°Âäπ„Å™Êé•Á∂ö„ÇíÂâäÈô§
        for connection in invalid_connections:
            if connection in self.active_connections:
                self.active_connections.remove(connection)

    def inject_components(
        self,
        prediction_engine: Optional[LivePredictionEngine] = None,
        performance_monitor: Optional[RealTimePerformanceMonitor] = None,
        alert_manager: Optional[AlertManager] = None,
        stream_manager: Optional[RealTimeStreamManager] = None,
    ):
        """„Ç∑„Çπ„ÉÜ„É†„Ç≥„É≥„Éù„Éº„Éç„É≥„ÉàÊ≥®ÂÖ•"""

        self.prediction_engine = prediction_engine
        self.performance_monitor = performance_monitor
        self.alert_manager = alert_manager
        self.stream_manager = stream_manager

        logger.info("System components injected into dashboard")

    async def start_dashboard(self, host: str = "0.0.0.0", port: int = 8000):
        """„ÉÄ„ÉÉ„Ç∑„É•„Éú„Éº„ÉâÈñãÂßã"""

        self.is_running = True

        # „Éá„Éº„ÇøÊõ¥Êñ∞„Çø„Çπ„ÇØÈñãÂßã
        self.update_task = asyncio.create_task(self._update_loop())

        logger.info(f"Starting dashboard server on {host}:{port}")

        # uvicorn „Çµ„Éº„Éê„ÉºËµ∑Âãï
        config = uvicorn.Config(self.app, host=host, port=port, log_level="info")
        server = uvicorn.Server(config)

        try:
            await server.serve()
        except Exception as e:
            logger.error(f"Dashboard server error: {e}")
        finally:
            await self.stop_dashboard()

    async def stop_dashboard(self):
        """„ÉÄ„ÉÉ„Ç∑„É•„Éú„Éº„ÉâÂÅúÊ≠¢"""

        self.is_running = False

        # Êõ¥Êñ∞„Çø„Çπ„ÇØÂÅúÊ≠¢
        if self.update_task and not self.update_task.done():
            self.update_task.cancel()
            try:
                await self.update_task
            except asyncio.CancelledError:
                pass

        # WebSocketÊé•Á∂öÁµÇ‰∫Ü
        for connection in self.active_connections.copy():
            try:
                await connection.close()
            except Exception:
                pass

        self.active_connections.clear()
        logger.info("Dashboard stopped")

    async def _update_loop(self):
        """„Éá„Éº„ÇøÊõ¥Êñ∞„É´„Éº„Éó"""

        logger.info("Dashboard update loop started")

        while self.is_running:
            try:
                # „ÉÄ„ÉÉ„Ç∑„É•„Éú„Éº„Éâ„Éá„Éº„ÇøÂèéÈõÜ
                updated_data = await self._collect_dashboard_data()

                # WebSocket „Éñ„É≠„Éº„Éâ„Ç≠„É£„Çπ„Éà
                if updated_data:
                    await self.broadcast_update(updated_data)

                # 5ÁßíÈñìÈöî„ÅßÊõ¥Êñ∞
                await asyncio.sleep(5)

            except Exception as e:
                logger.error(f"Dashboard update error: {e}")
                await asyncio.sleep(1)

    async def _collect_dashboard_data(self) -> Dict[str, Any]:
        """„ÉÄ„ÉÉ„Ç∑„É•„Éú„Éº„Éâ„Éá„Éº„ÇøÂèéÈõÜ"""

        data = {
            "timestamp": datetime.now().isoformat(),
            "system": {},
            "ai": {},
            "trading": {},
            "alerts": [],
        }

        try:
            # „Ç∑„Çπ„ÉÜ„É†Áä∂Ê≥Å
            if self.performance_monitor:
                comprehensive_status = (
                    self.performance_monitor.get_comprehensive_status()
                )
                system_summary = comprehensive_status.get("system_summary", {})
                data["system"] = {
                    "cpu_percent": system_summary.get("cpu", {}).get("current", 0),
                    "memory_percent": system_summary.get("memory", {}).get(
                        "current", 0
                    ),
                    "status": (
                        "healthy"
                        if system_summary.get("cpu", {}).get("current", 0) < 70
                        else "warning"
                    ),
                    "active_tasks": comprehensive_status.get(
                        "monitoring_stats", {}
                    ).get("total_monitoring_cycles", 0),
                }

                # AIÊÄßËÉΩ
                ai_summary = comprehensive_status.get("ai_summary", {})
                data["ai"] = {
                    "total_predictions": ai_summary.get("total_predictions", 0),
                    "success_rate": ai_summary.get("success_rate", 0),
                    "average_latency": ai_summary.get("average_latency_ms", 0),
                    "status": (
                        "healthy"
                        if ai_summary.get("error_rate", 0) < 0.1
                        else "warning"
                    ),
                }

                # ÂèñÂºï„Éë„Éï„Ç©„Éº„Éû„É≥„Çπ
                trading_summary = comprehensive_status.get("trading_summary", {})
                data["trading"] = {
                    "total_signals": trading_summary.get("total_signals", 0),
                    "virtual_return": trading_summary.get("virtual_return", 0),
                    "virtual_drawdown": trading_summary.get("virtual_drawdown", 0),
                    "status": (
                        "healthy"
                        if trading_summary.get("virtual_drawdown", 0) < 0.05
                        else "warning"
                    ),
                }

            # „Ç¢„É©„Éº„ÉàÊÉÖÂ†±
            if self.alert_manager:
                recent_alerts = self.alert_manager.get_alert_history(hours=24)
                data["alerts"] = [
                    {
                        "id": alert.id,
                        "timestamp": alert.timestamp.isoformat(),
                        "level": alert.level.value,
                        "title": alert.title,
                        "message": alert.message,
                        "acknowledged": alert.acknowledged,
                        "resolved": alert.resolved,
                    }
                    for alert in recent_alerts[-10:]  # ÊúÄÊñ∞10‰ª∂
                ]

        except Exception as e:
            logger.error(f"Dashboard data collection error: {e}")

        return data

    def _get_system_status(self) -> Dict[str, Any]:
        """„Ç∑„Çπ„ÉÜ„É†Áä∂Ê≥ÅÂèñÂæó"""

        if self.performance_monitor:
            return self.performance_monitor.get_comprehensive_status()

        return {"status": "unknown", "message": "Performance monitor not available"}

    def _get_recent_predictions(self) -> List[Dict]:
        """ÊúÄËøë„ÅÆ‰∫àÊ∏¨ÂèñÂæó"""

        # Á∞°Áï•ÂåñÂÆüË£ÖÔºàÂÆüÈöõ„ÅÆLivePredictionEngine„Åã„ÇâÂèñÂæóÔºâ
        return []

    def _get_performance_metrics(self) -> Dict:
        """„Éë„Éï„Ç©„Éº„Éû„É≥„ÇπÊåáÊ®ôÂèñÂæó"""

        if self.performance_monitor:
            return self.performance_monitor.get_dashboard_data()

        return {}

    def _get_recent_alerts(self) -> List[Dict]:
        """ÊúÄËøë„ÅÆ„Ç¢„É©„Éº„ÉàÂèñÂæó"""

        if self.alert_manager:
            alerts = self.alert_manager.get_alert_history(hours=24)
            return [alert.to_dict() for alert in alerts[-20:]]  # ÊúÄÊñ∞20‰ª∂

        return []

    def _get_market_data(self) -> Dict:
        """Â∏ÇÂ†¥„Éá„Éº„ÇøÂèñÂæó"""

        if self.stream_manager:
            return self.stream_manager.get_latest_data()

        return {}

    async def _restart_components(self):
        """„Ç∑„Çπ„ÉÜ„É†„Ç≥„É≥„Éù„Éº„Éç„É≥„ÉàÂÜçËµ∑Âãï"""

        logger.info("Restarting system components...")

        # ÂêÑ„Ç≥„É≥„Éù„Éº„Éç„É≥„Éà„ÅÆÂÜçËµ∑Âãï„É≠„Ç∏„ÉÉ„ÇØÂÆüË£Ö
        # ÂÆüÈöõ„ÅÆÂÆüË£Ö„Åß„ÅØÂêÑ„Ç≥„É≥„Éù„Éº„Éç„É≥„Éà„ÅÆÂÜçËµ∑Âãï„É°„ÇΩ„ÉÉ„Éâ„ÇíÂëº„Å≥Âá∫„Åó

        await asyncio.sleep(2)  # Ê®°Êì¨ÂÜçËµ∑ÂãïÊôÇÈñì

        logger.info("System components restarted")


# ‰æøÂà©Èñ¢Êï∞
def create_dashboard_manager() -> DashboardManager:
    """„ÉÄ„ÉÉ„Ç∑„É•„Éú„Éº„ÉâÁÆ°ÁêÜ„Ç∑„Çπ„ÉÜ„É†‰ΩúÊàê"""

    return DashboardManager()


async def start_dashboard_server(
    prediction_engine: Optional[LivePredictionEngine] = None,
    performance_monitor: Optional[RealTimePerformanceMonitor] = None,
    alert_manager: Optional[AlertManager] = None,
    stream_manager: Optional[RealTimeStreamManager] = None,
    host: str = "0.0.0.0",
    port: int = 8000,
):
    """„ÉÄ„ÉÉ„Ç∑„É•„Éú„Éº„Éâ„Çµ„Éº„Éê„ÉºËµ∑Âãï"""

    dashboard = create_dashboard_manager()

    # „Ç∑„Çπ„ÉÜ„É†„Ç≥„É≥„Éù„Éº„Éç„É≥„ÉàÊ≥®ÂÖ•
    dashboard.inject_components(
        prediction_engine=prediction_engine,
        performance_monitor=performance_monitor,
        alert_manager=alert_manager,
        stream_manager=stream_manager,
    )

    # „Çµ„Éº„Éê„ÉºËµ∑Âãï
    await dashboard.start_dashboard(host=host, port=port)


if __name__ == "__main__":
    # „ÉÄ„ÉÉ„Ç∑„É•„Éú„Éº„Éâ„ÉÜ„Çπ„Éà
    async def test_dashboard():
        print("=== Dashboard System Test ===")

        try:
            # „ÉÄ„ÉÉ„Ç∑„É•„Éú„Éº„Éâ‰ΩúÊàê
            dashboard = create_dashboard_manager()

            print("Starting dashboard server...")
            print("Open http://localhost:8000 in your browser")

            # „Çµ„Éº„Éê„ÉºËµ∑ÂãïÔºà„ÉÜ„Çπ„ÉàÁî®„Å´Áü≠ÊôÇÈñìÔºâ
            await asyncio.wait_for(
                dashboard.start_dashboard(host="0.0.0.0", port=8000),
                timeout=30,  # 30Áßí„Åß„Çø„Ç§„É†„Ç¢„Ç¶„Éà
            )

        except asyncio.TimeoutError:
            print("Dashboard test completed (timeout)")
        except Exception as e:
            print(f"Test error: {e}")
            import traceback

            traceback.print_exc()

    # „ÉÜ„Çπ„ÉàÂÆüË°å
    asyncio.run(test_dashboard())
