"""
依存関係脆弱性管理システム
Issue #419: セキュリティ対策の強化と脆弱性管理プロセスの確立

pip-audit、safety、Snyk等の統合による包括的な依存関係脆弱性管理。
"""

import asyncio
import json
import sqlite3
import subprocess
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from typing import Any, Dict, List, Optional

try:
    import requests

    REQUESTS_AVAILABLE = True
except ImportError:
    REQUESTS_AVAILABLE = False


class VulnerabilityLevel(Enum):
    """脆弱性重要度"""

    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"
    CRITICAL = "critical"


class VulnerabilityStatus(Enum):
    """脆弱性状態"""

    DETECTED = "detected"
    ACKNOWLEDGED = "acknowledged"
    MITIGATED = "mitigated"
    RESOLVED = "resolved"
    FALSE_POSITIVE = "false_positive"


@dataclass
class VulnerabilityReport:
    """脆弱性レポート"""

    id: str
    package_name: str
    package_version: str
    vulnerability_id: str
    title: str
    description: str
    level: VulnerabilityLevel
    status: VulnerabilityStatus
    detected_at: datetime
    cve_ids: List[str] = field(default_factory=list)
    fix_versions: List[str] = field(default_factory=list)
    references: List[str] = field(default_factory=list)
    remediation: Optional[str] = None
    acknowledged_at: Optional[datetime] = None
    acknowledged_by: Optional[str] = None
    resolution_notes: Optional[str] = None


@dataclass
class ScanResult:
    """スキャン結果"""

    scan_id: str
    tool: str
    started_at: datetime
    completed_at: datetime
    total_packages: int
    vulnerabilities_found: int
    vulnerabilities: List[VulnerabilityReport]
    scan_successful: bool
    error_message: Optional[str] = None


class PipAuditScanner:
    """pip-audit統合スキャナー"""

    async def scan(self) -> ScanResult:
        """pip-auditによる脆弱性スキャン"""
        scan_id = f"pip_audit_{int(datetime.utcnow().timestamp())}"
        started_at = datetime.utcnow()

        try:
            # pip-auditコマンドを実行
            result = subprocess.run(
                ["pip-audit", "--format=json", "--desc"],
                capture_output=True,
                text=True,
                timeout=300,
            )

            completed_at = datetime.utcnow()

            if result.returncode == 0:
                # 脆弱性なしの場合
                return ScanResult(
                    scan_id=scan_id,
                    tool="pip-audit",
                    started_at=started_at,
                    completed_at=completed_at,
                    total_packages=0,
                    vulnerabilities_found=0,
                    vulnerabilities=[],
                    scan_successful=True,
                )
            else:
                # 脆弱性ありまたはエラー
                try:
                    output = json.loads(result.stdout)
                    vulnerabilities = []

                    for vuln_data in output:
                        vuln = VulnerabilityReport(
                            id=f"pip_audit_{vuln_data.get('id', 'unknown')}",
                            package_name=vuln_data.get("package", "unknown"),
                            package_version=vuln_data.get(
                                "installed_version", "unknown"
                            ),
                            vulnerability_id=vuln_data.get("id", "unknown"),
                            title=vuln_data.get("description", "")[:100],
                            description=vuln_data.get("description", ""),
                            level=self._parse_severity(
                                vuln_data.get("severity", "medium")
                            ),
                            status=VulnerabilityStatus.DETECTED,
                            detected_at=started_at,
                            fix_versions=vuln_data.get("fix_versions", []),
                        )
                        vulnerabilities.append(vuln)

                    return ScanResult(
                        scan_id=scan_id,
                        tool="pip-audit",
                        started_at=started_at,
                        completed_at=completed_at,
                        total_packages=len(
                            set(v.package_name for v in vulnerabilities)
                        ),
                        vulnerabilities_found=len(vulnerabilities),
                        vulnerabilities=vulnerabilities,
                        scan_successful=True,
                    )

                except json.JSONDecodeError:
                    return ScanResult(
                        scan_id=scan_id,
                        tool="pip-audit",
                        started_at=started_at,
                        completed_at=completed_at,
                        total_packages=0,
                        vulnerabilities_found=0,
                        vulnerabilities=[],
                        scan_successful=False,
                        error_message=f"Failed to parse output: {result.stderr}",
                    )

        except subprocess.TimeoutExpired:
            return ScanResult(
                scan_id=scan_id,
                tool="pip-audit",
                started_at=started_at,
                completed_at=datetime.utcnow(),
                total_packages=0,
                vulnerabilities_found=0,
                vulnerabilities=[],
                scan_successful=False,
                error_message="Scan timeout",
            )
        except Exception as e:
            return ScanResult(
                scan_id=scan_id,
                tool="pip-audit",
                started_at=started_at,
                completed_at=datetime.utcnow(),
                total_packages=0,
                vulnerabilities_found=0,
                vulnerabilities=[],
                scan_successful=False,
                error_message=str(e),
            )

    def _parse_severity(self, severity: str) -> VulnerabilityLevel:
        """重要度のパース"""
        severity_lower = severity.lower()
        if severity_lower in ["critical", "high"]:
            return (
                VulnerabilityLevel.CRITICAL
                if severity_lower == "critical"
                else VulnerabilityLevel.HIGH
            )
        elif severity_lower == "medium":
            return VulnerabilityLevel.MEDIUM
        else:
            return VulnerabilityLevel.LOW


class SafetyScanner:
    """Safety統合スキャナー"""

    async def scan(self) -> ScanResult:
        """Safetyによる脆弱性スキャン"""
        scan_id = f"safety_{int(datetime.utcnow().timestamp())}"
        started_at = datetime.utcnow()

        try:
            # safetyコマンドを実行
            result = subprocess.run(
                [
                    "safety",
                    "check",
                    "--json",
                    "--ignore=70612",  # False positiveが多いIDを除外
                ],
                capture_output=True,
                text=True,
                timeout=120,
            )

            completed_at = datetime.utcnow()

            if result.returncode == 0:
                return ScanResult(
                    scan_id=scan_id,
                    tool="safety",
                    started_at=started_at,
                    completed_at=completed_at,
                    total_packages=0,
                    vulnerabilities_found=0,
                    vulnerabilities=[],
                    scan_successful=True,
                )
            else:
                try:
                    # Safetyのアウトプット形式を処理
                    vulnerabilities = []

                    if result.stdout.strip():
                        output_lines = result.stdout.strip().split("\n")
                        for line in output_lines:
                            try:
                                vuln_data = json.loads(line)
                                vuln = VulnerabilityReport(
                                    id=f"safety_{vuln_data.get('vulnerability_id', 'unknown')}",
                                    package_name=vuln_data.get(
                                        "package_name", "unknown"
                                    ),
                                    package_version=vuln_data.get(
                                        "installed_version", "unknown"
                                    ),
                                    vulnerability_id=vuln_data.get(
                                        "vulnerability_id", "unknown"
                                    ),
                                    title=vuln_data.get("advisory", "")[:100],
                                    description=vuln_data.get("advisory", ""),
                                    level=VulnerabilityLevel.HIGH,  # Safetyは基本的にHIGH扱い
                                    status=VulnerabilityStatus.DETECTED,
                                    detected_at=started_at,
                                )
                                vulnerabilities.append(vuln)
                            except json.JSONDecodeError:
                                continue

                    return ScanResult(
                        scan_id=scan_id,
                        tool="safety",
                        started_at=started_at,
                        completed_at=completed_at,
                        total_packages=len(
                            set(v.package_name for v in vulnerabilities)
                        ),
                        vulnerabilities_found=len(vulnerabilities),
                        vulnerabilities=vulnerabilities,
                        scan_successful=True,
                    )

                except Exception as e:
                    return ScanResult(
                        scan_id=scan_id,
                        tool="safety",
                        started_at=started_at,
                        completed_at=completed_at,
                        total_packages=0,
                        vulnerabilities_found=0,
                        vulnerabilities=[],
                        scan_successful=False,
                        error_message=f"Failed to process output: {str(e)}",
                    )

        except subprocess.TimeoutExpired:
            return ScanResult(
                scan_id=scan_id,
                tool="safety",
                started_at=started_at,
                completed_at=datetime.utcnow(),
                total_packages=0,
                vulnerabilities_found=0,
                vulnerabilities=[],
                scan_successful=False,
                error_message="Scan timeout",
            )
        except Exception as e:
            return ScanResult(
                scan_id=scan_id,
                tool="safety",
                started_at=started_at,
                completed_at=datetime.utcnow(),
                total_packages=0,
                vulnerabilities_found=0,
                vulnerabilities=[],
                scan_successful=False,
                error_message=str(e),
            )


class BanditScanner:
    """Bandit統合スキャナー（コードレベル脆弱性）"""

    def __init__(self, target_path: str = "src/"):
        self.target_path = target_path

    async def scan(self) -> ScanResult:
        """Banditによるコードセキュリティスキャン"""
        scan_id = f"bandit_{int(datetime.utcnow().timestamp())}"
        started_at = datetime.utcnow()

        try:
            # banditコマンドを実行
            result = subprocess.run(
                [
                    "bandit",
                    "-r",
                    self.target_path,
                    "-f",
                    "json",
                    "-s",
                    "B110,B311,B101,B601",  # よくあるfalse positiveをスキップ
                ],
                capture_output=True,
                text=True,
                timeout=180,
            )

            completed_at = datetime.utcnow()

            try:
                output = json.loads(result.stdout)
                vulnerabilities = []

                for issue in output.get("results", []):
                    vuln = VulnerabilityReport(
                        id=f"bandit_{issue.get('test_id', 'unknown')}_{hash(issue.get('filename', ''))}",
                        package_name="source_code",
                        package_version="N/A",
                        vulnerability_id=issue.get("test_id", "unknown"),
                        title=issue.get("test_name", "")[:100],
                        description=f"{issue.get('issue_text', '')} in {issue.get('filename', '')}:{issue.get('line_number', '')}",
                        level=self._parse_bandit_severity(
                            issue.get("issue_severity", "MEDIUM")
                        ),
                        status=VulnerabilityStatus.DETECTED,
                        detected_at=started_at,
                        references=[
                            f"File: {issue.get('filename', '')}, Line: {issue.get('line_number', '')}"
                        ],
                    )
                    vulnerabilities.append(vuln)

                return ScanResult(
                    scan_id=scan_id,
                    tool="bandit",
                    started_at=started_at,
                    completed_at=completed_at,
                    total_packages=1,  # ソースコード全体を1パッケージとして扱う
                    vulnerabilities_found=len(vulnerabilities),
                    vulnerabilities=vulnerabilities,
                    scan_successful=True,
                )

            except json.JSONDecodeError:
                return ScanResult(
                    scan_id=scan_id,
                    tool="bandit",
                    started_at=started_at,
                    completed_at=completed_at,
                    total_packages=0,
                    vulnerabilities_found=0,
                    vulnerabilities=[],
                    scan_successful=False,
                    error_message="Failed to parse Bandit output",
                )

        except subprocess.TimeoutExpired:
            return ScanResult(
                scan_id=scan_id,
                tool="bandit",
                started_at=started_at,
                completed_at=datetime.utcnow(),
                total_packages=0,
                vulnerabilities_found=0,
                vulnerabilities=[],
                scan_successful=False,
                error_message="Scan timeout",
            )
        except Exception as e:
            return ScanResult(
                scan_id=scan_id,
                tool="bandit",
                started_at=started_at,
                completed_at=datetime.utcnow(),
                total_packages=0,
                vulnerabilities_found=0,
                vulnerabilities=[],
                scan_successful=False,
                error_message=str(e),
            )

    def _parse_bandit_severity(self, severity: str) -> VulnerabilityLevel:
        """Bandit重要度のパース"""
        if severity.upper() == "HIGH":
            return VulnerabilityLevel.HIGH
        elif severity.upper() == "MEDIUM":
            return VulnerabilityLevel.MEDIUM
        else:
            return VulnerabilityLevel.LOW


class DependencyVulnerabilityManager:
    """依存関係脆弱性管理システム"""

    def __init__(self, db_path: str = "security_vulnerabilities.db"):
        self.db_path = db_path
        self.scanners = {
            "pip-audit": PipAuditScanner(),
            "safety": SafetyScanner(),
            "bandit": BanditScanner(),
        }
        self._initialize_database()

    def _initialize_database(self):
        """データベースを初期化"""
        with sqlite3.connect(self.db_path) as conn:
            conn.execute(
                """
                CREATE TABLE IF NOT EXISTS vulnerabilities (
                    id TEXT PRIMARY KEY,
                    package_name TEXT NOT NULL,
                    package_version TEXT NOT NULL,
                    vulnerability_id TEXT NOT NULL,
                    title TEXT NOT NULL,
                    description TEXT,
                    level TEXT NOT NULL,
                    status TEXT NOT NULL,
                    detected_at DATETIME NOT NULL,
                    cve_ids TEXT,
                    fix_versions TEXT,
                    references TEXT,
                    remediation TEXT,
                    acknowledged_at DATETIME,
                    acknowledged_by TEXT,
                    resolution_notes TEXT
                )
            """
            )

            conn.execute(
                """
                CREATE TABLE IF NOT EXISTS scan_history (
                    scan_id TEXT PRIMARY KEY,
                    tool TEXT NOT NULL,
                    started_at DATETIME NOT NULL,
                    completed_at DATETIME NOT NULL,
                    total_packages INTEGER,
                    vulnerabilities_found INTEGER,
                    scan_successful BOOLEAN,
                    error_message TEXT
                )
            """
            )

            # インデックス作成
            conn.execute(
                "CREATE INDEX IF NOT EXISTS idx_vulnerabilities_level ON vulnerabilities(level)"
            )
            conn.execute(
                "CREATE INDEX IF NOT EXISTS idx_vulnerabilities_status ON vulnerabilities(status)"
            )
            conn.execute(
                "CREATE INDEX IF NOT EXISTS idx_scan_history_tool ON scan_history(tool)"
            )

            conn.commit()

    async def run_comprehensive_scan(self) -> Dict[str, ScanResult]:
        """包括的脆弱性スキャンの実行"""
        results = {}

        # 全スキャナーを並列実行
        tasks = []
        for tool_name, scanner in self.scanners.items():
            tasks.append(self._run_single_scan(tool_name, scanner))

        scan_results = await asyncio.gather(*tasks, return_exceptions=True)

        for i, (tool_name, _) in enumerate(self.scanners.items()):
            if isinstance(scan_results[i], Exception):
                # エラーの場合
                results[tool_name] = ScanResult(
                    scan_id=f"{tool_name}_error_{int(datetime.utcnow().timestamp())}",
                    tool=tool_name,
                    started_at=datetime.utcnow(),
                    completed_at=datetime.utcnow(),
                    total_packages=0,
                    vulnerabilities_found=0,
                    vulnerabilities=[],
                    scan_successful=False,
                    error_message=str(scan_results[i]),
                )
            else:
                results[tool_name] = scan_results[i]
                # データベースに保存
                self._save_scan_result(scan_results[i])

        return results

    async def _run_single_scan(self, tool_name: str, scanner) -> ScanResult:
        """個別スキャンの実行"""
        return await scanner.scan()

    def _save_scan_result(self, result: ScanResult):
        """スキャン結果をデータベースに保存"""
        with sqlite3.connect(self.db_path) as conn:
            # スキャン履歴を保存
            conn.execute(
                """
                INSERT OR REPLACE INTO scan_history
                (scan_id, tool, started_at, completed_at, total_packages,
                 vulnerabilities_found, scan_successful, error_message)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?)
            """,
                (
                    result.scan_id,
                    result.tool,
                    result.started_at.isoformat(),
                    result.completed_at.isoformat(),
                    result.total_packages,
                    result.vulnerabilities_found,
                    result.scan_successful,
                    result.error_message,
                ),
            )

            # 脆弱性を保存
            for vuln in result.vulnerabilities:
                conn.execute(
                    """
                    INSERT OR REPLACE INTO vulnerabilities
                    (id, package_name, package_version, vulnerability_id, title,
                     description, level, status, detected_at, cve_ids, fix_versions,
                     references, remediation, acknowledged_at, acknowledged_by, resolution_notes)
                    VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
                """,
                    (
                        vuln.id,
                        vuln.package_name,
                        vuln.package_version,
                        vuln.vulnerability_id,
                        vuln.title,
                        vuln.description,
                        vuln.level.value,
                        vuln.status.value,
                        vuln.detected_at.isoformat(),
                        json.dumps(vuln.cve_ids),
                        json.dumps(vuln.fix_versions),
                        json.dumps(vuln.references),
                        vuln.remediation,
                        (
                            vuln.acknowledged_at.isoformat()
                            if vuln.acknowledged_at
                            else None
                        ),
                        vuln.acknowledged_by,
                        vuln.resolution_notes,
                    ),
                )

            conn.commit()

    def get_vulnerabilities(
        self,
        level: Optional[VulnerabilityLevel] = None,
        status: Optional[VulnerabilityStatus] = None,
        limit: int = 100,
    ) -> List[VulnerabilityReport]:
        """脆弱性一覧を取得"""
        query = "SELECT * FROM vulnerabilities WHERE 1=1"
        params = []

        if level:
            query += " AND level = ?"
            params.append(level.value)

        if status:
            query += " AND status = ?"
            params.append(status.value)

        query += " ORDER BY detected_at DESC LIMIT ?"
        params.append(limit)

        vulnerabilities = []

        with sqlite3.connect(self.db_path) as conn:
            cursor = conn.execute(query, params)

            for row in cursor.fetchall():
                vuln = VulnerabilityReport(
                    id=row[0],
                    package_name=row[1],
                    package_version=row[2],
                    vulnerability_id=row[3],
                    title=row[4],
                    description=row[5] or "",
                    level=VulnerabilityLevel(row[6]),
                    status=VulnerabilityStatus(row[7]),
                    detected_at=datetime.fromisoformat(row[8]),
                    cve_ids=json.loads(row[9]) if row[9] else [],
                    fix_versions=json.loads(row[10]) if row[10] else [],
                    references=json.loads(row[11]) if row[11] else [],
                    remediation=row[12],
                    acknowledged_at=(
                        datetime.fromisoformat(row[13]) if row[13] else None
                    ),
                    acknowledged_by=row[14],
                    resolution_notes=row[15],
                )
                vulnerabilities.append(vuln)

        return vulnerabilities

    def acknowledge_vulnerability(
        self, vulnerability_id: str, acknowledged_by: str, notes: str = ""
    ):
        """脆弱性を確認済みとしてマーク"""
        with sqlite3.connect(self.db_path) as conn:
            conn.execute(
                """
                UPDATE vulnerabilities
                SET status = ?, acknowledged_at = ?, acknowledged_by = ?, resolution_notes = ?
                WHERE id = ?
            """,
                (
                    VulnerabilityStatus.ACKNOWLEDGED.value,
                    datetime.utcnow().isoformat(),
                    acknowledged_by,
                    notes,
                    vulnerability_id,
                ),
            )
            conn.commit()

    def resolve_vulnerability(self, vulnerability_id: str, resolution_notes: str = ""):
        """脆弱性を解決済みとしてマーク"""
        with sqlite3.connect(self.db_path) as conn:
            conn.execute(
                """
                UPDATE vulnerabilities
                SET status = ?, resolution_notes = ?
                WHERE id = ?
            """,
                (
                    VulnerabilityStatus.RESOLVED.value,
                    resolution_notes,
                    vulnerability_id,
                ),
            )
            conn.commit()

    def get_security_dashboard_data(self) -> Dict[str, Any]:
        """セキュリティダッシュボード用データを取得"""
        with sqlite3.connect(self.db_path) as conn:
            # 重要度別統計
            cursor = conn.execute(
                """
                SELECT level, COUNT(*)
                FROM vulnerabilities
                WHERE status != 'resolved'
                GROUP BY level
            """
            )
            level_stats = dict(cursor.fetchall())

            # 状態別統計
            cursor = conn.execute(
                """
                SELECT status, COUNT(*)
                FROM vulnerabilities
                GROUP BY status
            """
            )
            status_stats = dict(cursor.fetchall())

            # 最新スキャン結果
            cursor = conn.execute(
                """
                SELECT tool, MAX(completed_at) as latest_scan
                FROM scan_history
                WHERE scan_successful = 1
                GROUP BY tool
            """
            )
            latest_scans = dict(cursor.fetchall())

            return {
                "vulnerability_summary": {
                    "critical": level_stats.get("critical", 0),
                    "high": level_stats.get("high", 0),
                    "medium": level_stats.get("medium", 0),
                    "low": level_stats.get("low", 0),
                },
                "status_summary": status_stats,
                "latest_scans": latest_scans,
                "total_active": sum(level_stats.values()),
                "last_updated": datetime.utcnow().isoformat(),
            }


# グローバルインスタンス
_dependency_manager = None


def get_dependency_manager() -> DependencyVulnerabilityManager:
    """グローバル依存関係脆弱性管理を取得"""
    global _dependency_manager
    if _dependency_manager is None:
        _dependency_manager = DependencyVulnerabilityManager()
    return _dependency_manager
