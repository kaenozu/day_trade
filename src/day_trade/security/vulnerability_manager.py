#!/usr/bin/env python3
"""
脆弱性管理システム
Issue #419: セキュリティ強化 - 脆弱性管理プロセスの確立

依存関係スキャン、脆弱性トリアージ、修正追跡、
リスク評価を統合した包括的脆弱性管理システム
"""

import asyncio
import json
import logging
import time
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from datetime import datetime, timedelta
from enum import Enum, IntEnum
from pathlib import Path
from typing import Any, Dict, List, Optional

try:
    from ..utils.logging_config import get_context_logger
except ImportError:
    logging.basicConfig(level=logging.INFO)

    def get_context_logger(name):
        return logging.getLogger(name)


logger = get_context_logger(__name__)


class VulnerabilitySeverity(IntEnum):
    """脆弱性重要度"""

    CRITICAL = 4
    HIGH = 3
    MEDIUM = 2
    LOW = 1
    INFORMATIONAL = 0


class VulnerabilityStatus(Enum):
    """脆弱性ステータス"""

    DETECTED = "detected"
    TRIAGED = "triaged"
    ASSIGNED = "assigned"
    IN_PROGRESS = "in_progress"
    FIXED = "fixed"
    VERIFIED = "verified"
    CLOSED = "closed"
    IGNORED = "ignored"
    FALSE_POSITIVE = "false_positive"


class ScannerType(Enum):
    """スキャナータイプ"""

    PIP_AUDIT = "pip-audit"
    SAFETY = "safety"
    BANDIT = "bandit"
    SEMGREP = "semgrep"
    SNYK = "snyk"
    CUSTOM = "custom"


@dataclass
class VulnerabilityInfo:
    """脆弱性情報"""

    # 基本情報
    vulnerability_id: str
    cve_id: Optional[str] = None
    title: str = ""
    description: str = ""

    # 重要度・分類
    severity: VulnerabilitySeverity = VulnerabilitySeverity.MEDIUM
    cvss_score: Optional[float] = None
    cwe_id: Optional[str] = None

    # 影響範囲
    affected_package: str = ""
    affected_versions: List[str] = field(default_factory=list)
    fixed_versions: List[str] = field(default_factory=list)

    # 検出情報
    scanner_type: ScannerType = ScannerType.CUSTOM
    detected_at: datetime = field(default_factory=datetime.utcnow)
    file_path: Optional[str] = None
    line_number: Optional[int] = None

    # 管理情報
    status: VulnerabilityStatus = VulnerabilityStatus.DETECTED
    assigned_to: Optional[str] = None
    due_date: Optional[datetime] = None

    # 追跡情報
    created_at: datetime = field(default_factory=datetime.utcnow)
    updated_at: datetime = field(default_factory=datetime.utcnow)
    resolution_notes: str = ""

    # リスク評価
    exploitability: str = "unknown"  # unknown, low, medium, high
    impact_assessment: str = ""
    business_risk: str = "unknown"  # low, medium, high, critical

    def to_dict(self) -> Dict[str, Any]:
        """辞書形式変換"""
        return {
            "vulnerability_id": self.vulnerability_id,
            "cve_id": self.cve_id,
            "title": self.title,
            "description": self.description,
            "severity": self.severity.name,
            "cvss_score": self.cvss_score,
            "cwe_id": self.cwe_id,
            "affected_package": self.affected_package,
            "affected_versions": self.affected_versions,
            "fixed_versions": self.fixed_versions,
            "scanner_type": self.scanner_type.value,
            "detected_at": self.detected_at.isoformat(),
            "file_path": self.file_path,
            "line_number": self.line_number,
            "status": self.status.value,
            "assigned_to": self.assigned_to,
            "due_date": self.due_date.isoformat() if self.due_date else None,
            "created_at": self.created_at.isoformat(),
            "updated_at": self.updated_at.isoformat(),
            "resolution_notes": self.resolution_notes,
            "exploitability": self.exploitability,
            "impact_assessment": self.impact_assessment,
            "business_risk": self.business_risk,
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "VulnerabilityInfo":
        """辞書から復元"""
        return cls(
            vulnerability_id=data["vulnerability_id"],
            cve_id=data.get("cve_id"),
            title=data.get("title", ""),
            description=data.get("description", ""),
            severity=VulnerabilitySeverity[data.get("severity", "MEDIUM")],
            cvss_score=data.get("cvss_score"),
            cwe_id=data.get("cwe_id"),
            affected_package=data.get("affected_package", ""),
            affected_versions=data.get("affected_versions", []),
            fixed_versions=data.get("fixed_versions", []),
            scanner_type=ScannerType(data.get("scanner_type", "custom")),
            detected_at=(
                datetime.fromisoformat(data["detected_at"])
                if data.get("detected_at")
                else datetime.utcnow()
            ),
            file_path=data.get("file_path"),
            line_number=data.get("line_number"),
            status=VulnerabilityStatus(data.get("status", "detected")),
            assigned_to=data.get("assigned_to"),
            due_date=datetime.fromisoformat(data["due_date"]) if data.get("due_date") else None,
            created_at=(
                datetime.fromisoformat(data["created_at"])
                if data.get("created_at")
                else datetime.utcnow()
            ),
            updated_at=(
                datetime.fromisoformat(data["updated_at"])
                if data.get("updated_at")
                else datetime.utcnow()
            ),
            resolution_notes=data.get("resolution_notes", ""),
            exploitability=data.get("exploitability", "unknown"),
            impact_assessment=data.get("impact_assessment", ""),
            business_risk=data.get("business_risk", "unknown"),
        )


class VulnerabilityScanner(ABC):
    """脆弱性スキャナー基底クラス"""

    @abstractmethod
    async def scan(self, target_path: str) -> List[VulnerabilityInfo]:
        """脆弱性スキャン実行"""
        pass

    @abstractmethod
    def get_scanner_type(self) -> ScannerType:
        """スキャナータイプ取得"""
        pass


class PipAuditScanner(VulnerabilityScanner):
    """pip-audit脆弱性スキャナー"""

    def __init__(self):
        self.scanner_type = ScannerType.PIP_AUDIT

    async def scan(self, target_path: str) -> List[VulnerabilityInfo]:
        """pip-auditスキャン実行"""
        try:
            # pip-audit実行
            process = await asyncio.create_subprocess_exec(
                "pip-audit",
                "--format=json",
                "--desc",
                cwd=target_path,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE,
            )

            stdout, stderr = await process.communicate()

            if process.returncode != 0:
                logger.warning(f"pip-audit実行エラー: {stderr.decode()}")
                return []

            # JSON解析
            audit_results = json.loads(stdout.decode())

            vulnerabilities = []
            for vuln in audit_results.get("vulnerabilities", []):
                vuln_info = VulnerabilityInfo(
                    vulnerability_id=f"pip-audit-{vuln.get('id', 'unknown')}",
                    cve_id=vuln.get("id"),
                    title=f"Vulnerability in {vuln.get('package', 'unknown')}",
                    description=vuln.get("description", ""),
                    affected_package=vuln.get("package", ""),
                    affected_versions=[vuln.get("installed_version", "")],
                    fixed_versions=vuln.get("fixed_versions", []),
                    scanner_type=self.scanner_type,
                    severity=self._map_severity(vuln.get("vulnerability_description", "")),
                )
                vulnerabilities.append(vuln_info)

            return vulnerabilities

        except Exception as e:
            logger.error(f"pip-auditスキャンエラー: {e}")
            return []

    def _map_severity(self, description: str) -> VulnerabilitySeverity:
        """重要度マッピング"""
        description_lower = description.lower()
        if any(
            word in description_lower
            for word in ["critical", "remote code execution", "privilege escalation"]
        ):
            return VulnerabilitySeverity.CRITICAL
        elif any(word in description_lower for word in ["high", "denial of service", "injection"]):
            return VulnerabilitySeverity.HIGH
        elif any(word in description_lower for word in ["medium", "information disclosure"]):
            return VulnerabilitySeverity.MEDIUM
        else:
            return VulnerabilitySeverity.LOW

    def get_scanner_type(self) -> ScannerType:
        return self.scanner_type


class SafetyScanner(VulnerabilityScanner):
    """safety脆弱性スキャナー"""

    def __init__(self):
        self.scanner_type = ScannerType.SAFETY

    async def scan(self, target_path: str) -> List[VulnerabilityInfo]:
        """safetyスキャン実行"""
        try:
            # safety実行
            process = await asyncio.create_subprocess_exec(
                "safety",
                "check",
                "--json",
                "--short-report",
                cwd=target_path,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE,
            )

            stdout, stderr = await process.communicate()

            # safety は脆弱性が見つかった場合に非ゼロ終了コードを返すので、
            # エラーハンドリングを調整
            if stdout:
                try:
                    safety_results = json.loads(stdout.decode())
                except json.JSONDecodeError:
                    # JSON形式でない場合はテキスト解析
                    return self._parse_text_output(stdout.decode())
            else:
                return []

            vulnerabilities = []
            for vuln in safety_results:
                vuln_info = VulnerabilityInfo(
                    vulnerability_id=f"safety-{vuln.get('advisory', 'unknown')}",
                    cve_id=vuln.get("advisory"),
                    title=f"Vulnerability in {vuln.get('package_name', 'unknown')}",
                    description=vuln.get("vulnerability", ""),
                    affected_package=vuln.get("package_name", ""),
                    affected_versions=[vuln.get("installed_version", "")],
                    scanner_type=self.scanner_type,
                    severity=VulnerabilitySeverity.HIGH,  # safetyは一般的に重要な脆弱性を検出
                )
                vulnerabilities.append(vuln_info)

            return vulnerabilities

        except Exception as e:
            logger.error(f"safetyスキャンエラー: {e}")
            return []

    def _parse_text_output(self, output: str) -> List[VulnerabilityInfo]:
        """テキスト出力の解析"""
        vulnerabilities = []
        lines = output.strip().split("\n")

        for line in lines:
            if "vulnerability" in line.lower() and "==" in line:
                parts = line.split("==")
                if len(parts) >= 2:
                    package_name = parts[0].strip()
                    vuln_info = VulnerabilityInfo(
                        vulnerability_id=f"safety-{package_name}-{int(time.time())}",
                        title=f"Vulnerability in {package_name}",
                        description=line.strip(),
                        affected_package=package_name,
                        scanner_type=self.scanner_type,
                        severity=VulnerabilitySeverity.HIGH,
                    )
                    vulnerabilities.append(vuln_info)

        return vulnerabilities

    def get_scanner_type(self) -> ScannerType:
        return self.scanner_type


class BanditScanner(VulnerabilityScanner):
    """bandit静的解析スキャナー"""

    def __init__(self):
        self.scanner_type = ScannerType.BANDIT

    async def scan(self, target_path: str) -> List[VulnerabilityInfo]:
        """banditスキャン実行"""
        try:
            # bandit実行
            process = await asyncio.create_subprocess_exec(
                "bandit",
                "-r",
                target_path,
                "-f",
                "json",
                "-q",
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE,
            )

            stdout, stderr = await process.communicate()

            if not stdout:
                return []

            try:
                bandit_results = json.loads(stdout.decode())
            except json.JSONDecodeError:
                logger.warning("bandit出力のJSON解析に失敗")
                return []

            vulnerabilities = []
            for result in bandit_results.get("results", []):
                vuln_info = VulnerabilityInfo(
                    vulnerability_id=f"bandit-{result.get('test_id', 'unknown')}-{result.get('line_number', 0)}",
                    cve_id=result.get("test_id"),
                    title=result.get("test_name", ""),
                    description=result.get("issue_text", ""),
                    severity=self._map_bandit_severity(result.get("issue_severity", "MEDIUM")),
                    scanner_type=self.scanner_type,
                    file_path=result.get("filename"),
                    line_number=result.get("line_number"),
                    cwe_id=result.get("test_id"),
                )
                vulnerabilities.append(vuln_info)

            return vulnerabilities

        except Exception as e:
            logger.error(f"banditスキャンエラー: {e}")
            return []

    def _map_bandit_severity(self, severity: str) -> VulnerabilitySeverity:
        """bandit重要度マッピング"""
        severity_map = {
            "HIGH": VulnerabilitySeverity.HIGH,
            "MEDIUM": VulnerabilitySeverity.MEDIUM,
            "LOW": VulnerabilitySeverity.LOW,
        }
        return severity_map.get(severity.upper(), VulnerabilitySeverity.MEDIUM)

    def get_scanner_type(self) -> ScannerType:
        return self.scanner_type


@dataclass
class ScanResult:
    """スキャン結果"""

    scan_id: str
    scan_type: ScannerType
    target_path: str
    start_time: datetime
    end_time: Optional[datetime] = None
    status: str = "running"  # running, completed, failed
    vulnerabilities: List[VulnerabilityInfo] = field(default_factory=list)
    error_message: Optional[str] = None

    def to_dict(self) -> Dict[str, Any]:
        return {
            "scan_id": self.scan_id,
            "scan_type": self.scan_type.value,
            "target_path": self.target_path,
            "start_time": self.start_time.isoformat(),
            "end_time": self.end_time.isoformat() if self.end_time else None,
            "status": self.status,
            "vulnerabilities": [v.to_dict() for v in self.vulnerabilities],
            "error_message": self.error_message,
        }


class VulnerabilityManager:
    """
    脆弱性管理マネージャー

    複数のスキャナーを統合し、脆弱性のライフサイクル管理、
    トリアージ、修正追跡を行う中央管理システム
    """

    def __init__(
        self,
        storage_path: str = "security/vulnerabilities",
        scan_config_path: Optional[str] = None,
    ):
        """
        初期化

        Args:
            storage_path: 脆弱性データ保存パス
            scan_config_path: スキャン設定ファイルパス
        """
        self.storage_path = Path(storage_path)
        self.storage_path.mkdir(parents=True, exist_ok=True)

        # スキャナー登録
        self.scanners: Dict[ScannerType, VulnerabilityScanner] = {
            ScannerType.PIP_AUDIT: PipAuditScanner(),
            ScannerType.SAFETY: SafetyScanner(),
            ScannerType.BANDIT: BanditScanner(),
        }

        # 脆弱性データベース（メモリ）
        self.vulnerabilities: Dict[str, VulnerabilityInfo] = {}
        self.scan_results: Dict[str, ScanResult] = {}

        # 設定
        self.scan_config = self._load_scan_config(scan_config_path)

        # 自動修正設定
        self.auto_fix_enabled = self.scan_config.get("auto_fix_enabled", False)

        # データ読み込み
        self._load_vulnerabilities()

        logger.info("VulnerabilityManager初期化完了")

    def _load_scan_config(self, config_path: Optional[str]) -> Dict[str, Any]:
        """スキャン設定読み込み"""
        default_config = {
            "enabled_scanners": ["pip-audit", "safety", "bandit"],
            "scan_schedule": {"daily": True, "weekly_full_scan": True},
            "severity_thresholds": {
                "critical_sla_hours": 4,
                "high_sla_hours": 24,
                "medium_sla_hours": 168,  # 1週間
                "low_sla_hours": 720,  # 30日
            },
            "auto_fix_enabled": False,
            "notification_channels": ["console", "file"],
            "exclude_patterns": ["test_*", "*_test.py", "demo_*", "example_*"],
        }

        if config_path and Path(config_path).exists():
            try:
                with open(config_path, encoding="utf-8") as f:
                    loaded_config = json.load(f)
                default_config.update(loaded_config)
            except Exception as e:
                logger.warning(f"設定読み込みエラー: {e}")

        return default_config

    def _load_vulnerabilities(self):
        """保存された脆弱性データ読み込み"""
        vuln_file = self.storage_path / "vulnerabilities.json"
        if vuln_file.exists():
            try:
                with open(vuln_file, encoding="utf-8") as f:
                    data = json.load(f)

                for vuln_id, vuln_data in data.get("vulnerabilities", {}).items():
                    self.vulnerabilities[vuln_id] = VulnerabilityInfo.from_dict(vuln_data)

                logger.info(f"脆弱性データ読み込み完了: {len(self.vulnerabilities)}件")

            except Exception as e:
                logger.error(f"脆弱性データ読み込みエラー: {e}")

    def _save_vulnerabilities(self):
        """脆弱性データ保存"""
        vuln_file = self.storage_path / "vulnerabilities.json"
        try:
            data = {
                "vulnerabilities": {
                    vuln_id: vuln.to_dict() for vuln_id, vuln in self.vulnerabilities.items()
                },
                "last_updated": datetime.utcnow().isoformat(),
            }

            with open(vuln_file, "w", encoding="utf-8") as f:
                json.dump(data, f, indent=2, ensure_ascii=False)

        except Exception as e:
            logger.error(f"脆弱性データ保存エラー: {e}")

    async def run_comprehensive_scan(
        self, target_path: str, scanner_types: Optional[List[ScannerType]] = None
    ) -> Dict[ScannerType, ScanResult]:
        """包括的脆弱性スキャン実行"""
        logger.info(f"包括的脆弱性スキャン開始: {target_path}")

        if scanner_types is None:
            scanner_types = list(self.scanners.keys())

        scan_results = {}

        # 並列スキャン実行
        tasks = []
        for scanner_type in scanner_types:
            if scanner_type in self.scanners:
                task = self._run_single_scan(scanner_type, target_path)
                tasks.append(task)

        # スキャン実行
        results = await asyncio.gather(*tasks, return_exceptions=True)

        # 結果処理
        for i, result in enumerate(results):
            scanner_type = scanner_types[i]
            if isinstance(result, Exception):
                logger.error(f"スキャンエラー {scanner_type}: {result}")
            else:
                scan_results[scanner_type] = result
                # 脆弱性データベース更新
                self._merge_scan_results(result)

        # データ保存
        self._save_vulnerabilities()

        logger.info(f"包括的スキャン完了: {len(scan_results)}件のスキャン結果")
        return scan_results

    async def _run_single_scan(self, scanner_type: ScannerType, target_path: str) -> ScanResult:
        """単一スキャナー実行"""
        scan_id = f"{scanner_type.value}-{int(time.time())}"
        start_time = datetime.utcnow()

        scan_result = ScanResult(
            scan_id=scan_id,
            scan_type=scanner_type,
            target_path=target_path,
            start_time=start_time,
        )

        try:
            scanner = self.scanners[scanner_type]
            vulnerabilities = await scanner.scan(target_path)

            scan_result.vulnerabilities = vulnerabilities
            scan_result.status = "completed"
            scan_result.end_time = datetime.utcnow()

            logger.info(f"{scanner_type.value}スキャン完了: {len(vulnerabilities)}件の脆弱性検出")

        except Exception as e:
            scan_result.status = "failed"
            scan_result.error_message = str(e)
            scan_result.end_time = datetime.utcnow()
            logger.error(f"{scanner_type.value}スキャン失敗: {e}")

        self.scan_results[scan_id] = scan_result
        return scan_result

    def _merge_scan_results(self, scan_result: ScanResult):
        """スキャン結果をデータベースにマージ"""
        for vuln in scan_result.vulnerabilities:
            existing_vuln = self.vulnerabilities.get(vuln.vulnerability_id)

            if existing_vuln:
                # 既存脆弱性の更新
                existing_vuln.updated_at = datetime.utcnow()
                existing_vuln.detected_at = vuln.detected_at
                # 他の情報も必要に応じて更新
            else:
                # 新規脆弱性
                vuln.status = VulnerabilityStatus.DETECTED
                self.vulnerabilities[vuln.vulnerability_id] = vuln

                # 自動トリアージ実行
                self._auto_triage_vulnerability(vuln)

    def _auto_triage_vulnerability(self, vuln: VulnerabilityInfo):
        """脆弱性自動トリアージ"""
        # 重要度に基づく期限設定
        severity_sla = self.scan_config["severity_thresholds"]

        if vuln.severity == VulnerabilitySeverity.CRITICAL:
            vuln.due_date = datetime.utcnow() + timedelta(hours=severity_sla["critical_sla_hours"])
        elif vuln.severity == VulnerabilitySeverity.HIGH:
            vuln.due_date = datetime.utcnow() + timedelta(hours=severity_sla["high_sla_hours"])
        elif vuln.severity == VulnerabilitySeverity.MEDIUM:
            vuln.due_date = datetime.utcnow() + timedelta(hours=severity_sla["medium_sla_hours"])
        else:
            vuln.due_date = datetime.utcnow() + timedelta(hours=severity_sla["low_sla_hours"])

        # 自動分類
        if vuln.severity in [
            VulnerabilitySeverity.CRITICAL,
            VulnerabilitySeverity.HIGH,
        ]:
            vuln.status = VulnerabilityStatus.TRIAGED

        logger.info(f"脆弱性自動トリアージ完了: {vuln.vulnerability_id} ({vuln.severity.name})")

    def get_vulnerability_summary(self) -> Dict[str, Any]:
        """脆弱性サマリー取得"""
        summary = {
            "total_vulnerabilities": len(self.vulnerabilities),
            "by_severity": {},
            "by_status": {},
            "by_scanner": {},
            "overdue_count": 0,
            "critical_open": 0,
        }

        now = datetime.utcnow()

        for vuln in self.vulnerabilities.values():
            # 重要度別
            severity_name = vuln.severity.name
            summary["by_severity"][severity_name] = summary["by_severity"].get(severity_name, 0) + 1

            # ステータス別
            status_name = vuln.status.value
            summary["by_status"][status_name] = summary["by_status"].get(status_name, 0) + 1

            # スキャナー別
            scanner_name = vuln.scanner_type.value
            summary["by_scanner"][scanner_name] = summary["by_scanner"].get(scanner_name, 0) + 1

            # 期限超過チェック
            if (
                vuln.due_date
                and now > vuln.due_date
                and vuln.status
                not in [
                    VulnerabilityStatus.FIXED,
                    VulnerabilityStatus.VERIFIED,
                    VulnerabilityStatus.CLOSED,
                ]
            ):
                summary["overdue_count"] += 1

            # 重要な未解決問題
            if vuln.severity == VulnerabilitySeverity.CRITICAL and vuln.status not in [
                VulnerabilityStatus.FIXED,
                VulnerabilityStatus.VERIFIED,
                VulnerabilityStatus.CLOSED,
            ]:
                summary["critical_open"] += 1

        return summary

    def get_vulnerabilities_by_severity(
        self, severity: VulnerabilitySeverity, include_resolved: bool = False
    ) -> List[VulnerabilityInfo]:
        """重要度別脆弱性取得"""
        filtered_vulnerabilities = []

        for vuln in self.vulnerabilities.values():
            if vuln.severity == severity:
                if include_resolved or vuln.status not in [
                    VulnerabilityStatus.FIXED,
                    VulnerabilityStatus.VERIFIED,
                    VulnerabilityStatus.CLOSED,
                ]:
                    filtered_vulnerabilities.append(vuln)

        # 検出日時でソート（新しい順）
        filtered_vulnerabilities.sort(key=lambda x: x.detected_at, reverse=True)

        return filtered_vulnerabilities

    def update_vulnerability_status(
        self,
        vulnerability_id: str,
        new_status: VulnerabilityStatus,
        notes: str = "",
        assigned_to: Optional[str] = None,
    ) -> bool:
        """脆弱性ステータス更新"""
        vuln = self.vulnerabilities.get(vulnerability_id)
        if not vuln:
            logger.error(f"脆弱性が見つかりません: {vulnerability_id}")
            return False

        old_status = vuln.status
        vuln.status = new_status
        vuln.updated_at = datetime.utcnow()

        if notes:
            vuln.resolution_notes = notes

        if assigned_to:
            vuln.assigned_to = assigned_to

        logger.info(
            f"脆弱性ステータス更新: {vulnerability_id} {old_status.value} -> {new_status.value}"
        )

        # データ保存
        self._save_vulnerabilities()

        return True

    async def generate_security_report(self) -> Dict[str, Any]:
        """セキュリティレポート生成"""
        logger.info("セキュリティレポート生成開始")

        summary = self.get_vulnerability_summary()

        # 重要度別詳細
        severity_details = {}
        for severity in VulnerabilitySeverity:
            vulnerabilities = self.get_vulnerabilities_by_severity(severity)
            severity_details[severity.name] = {
                "count": len(vulnerabilities),
                "vulnerabilities": [
                    {
                        "id": v.vulnerability_id,
                        "title": v.title,
                        "package": v.affected_package,
                        "status": v.status.value,
                        "detected_at": v.detected_at.isoformat(),
                        "due_date": v.due_date.isoformat() if v.due_date else None,
                    }
                    for v in vulnerabilities[:10]  # 上位10件のみ
                ],
            }

        # スキャン履歴
        recent_scans = sorted(self.scan_results.values(), key=lambda x: x.start_time, reverse=True)[
            :10
        ]

        scan_history = [
            {
                "scan_id": scan.scan_id,
                "scanner_type": scan.scan_type.value,
                "start_time": scan.start_time.isoformat(),
                "status": scan.status,
                "vulnerabilities_found": len(scan.vulnerabilities),
            }
            for scan in recent_scans
        ]

        report = {
            "report_id": f"security-report-{int(time.time())}",
            "generated_at": datetime.utcnow().isoformat(),
            "summary": summary,
            "severity_details": severity_details,
            "scan_history": scan_history,
            "recommendations": self._generate_recommendations(summary),
        }

        # レポート保存
        report_file = self.storage_path / f"security_report_{int(time.time())}.json"
        with open(report_file, "w", encoding="utf-8") as f:
            json.dump(report, f, indent=2, ensure_ascii=False)

        logger.info(f"セキュリティレポート生成完了: {report_file}")

        return report

    def _generate_recommendations(self, summary: Dict[str, Any]) -> List[str]:
        """推奨事項生成"""
        recommendations = []

        if summary["critical_open"] > 0:
            recommendations.append(
                f"🚨 {summary['critical_open']}件の重要な脆弱性が未解決です。直ちに対応してください。"
            )

        if summary["overdue_count"] > 0:
            recommendations.append(
                f"⏰ {summary['overdue_count']}件の脆弱性が期限を過ぎています。優先的に対応してください。"
            )

        if summary["by_severity"].get("HIGH", 0) > 5:
            recommendations.append(
                "🔍 高重要度の脆弱性が多数検出されています。依存関係の更新を検討してください。"
            )

        if summary["total_vulnerabilities"] == 0:
            recommendations.append(
                "✅ 脆弱性は検出されていません。定期的なスキャンを継続してください。"
            )
        else:
            recommendations.append(
                "🔄 定期的な依存関係の更新とセキュリティスキャンを実行してください。"
            )

        return recommendations

    async def cleanup(self):
        """クリーンアップ"""
        logger.info("VulnerabilityManager クリーンアップ開始")

        # 最終データ保存
        self._save_vulnerabilities()

        logger.info("クリーンアップ完了")


# Factory function
def create_vulnerability_manager(
    storage_path: str = "security/vulnerabilities",
    scan_config_path: Optional[str] = None,
) -> VulnerabilityManager:
    """VulnerabilityManagerファクトリ関数"""
    return VulnerabilityManager(storage_path=storage_path, scan_config_path=scan_config_path)


if __name__ == "__main__":
    # テスト実行
    async def main():
        print("=== Issue #419 脆弱性管理システムテスト ===")

        manager = None
        try:
            # 脆弱性管理システム初期化
            manager = create_vulnerability_manager()

            print("\n1. 包括的脆弱性スキャン実行")
            target_path = "."

            scan_results = await manager.run_comprehensive_scan(target_path)

            print(f"スキャン完了: {len(scan_results)}種類のスキャナーを実行")
            for scanner_type, result in scan_results.items():
                print(f"  {scanner_type.value}: {len(result.vulnerabilities)}件の脆弱性検出")

            print("\n2. 脆弱性サマリー")
            summary = manager.get_vulnerability_summary()
            print(f"総脆弱性数: {summary['total_vulnerabilities']}件")

            if summary["by_severity"]:
                print("重要度別:")
                for severity, count in summary["by_severity"].items():
                    print(f"  {severity}: {count}件")

            if summary["by_status"]:
                print("ステータス別:")
                for status, count in summary["by_status"].items():
                    print(f"  {status}: {count}件")

            print(f"期限超過: {summary['overdue_count']}件")
            print(f"重要な未解決: {summary['critical_open']}件")

            print("\n3. 重要度別詳細")
            for severity in [
                VulnerabilitySeverity.CRITICAL,
                VulnerabilitySeverity.HIGH,
            ]:
                vulnerabilities = manager.get_vulnerabilities_by_severity(severity)
                if vulnerabilities:
                    print(f"\n{severity.name}重要度 ({len(vulnerabilities)}件):")
                    for vuln in vulnerabilities[:3]:  # 上位3件表示
                        print(f"  - {vuln.title}")
                        print(f"    パッケージ: {vuln.affected_package}")
                        print(f"    ステータス: {vuln.status.value}")

            print("\n4. セキュリティレポート生成")
            report = await manager.generate_security_report()
            print(f"レポートID: {report['report_id']}")
            print(f"推奨事項数: {len(report['recommendations'])}")

            if report["recommendations"]:
                print("推奨事項:")
                for rec in report["recommendations"]:
                    print(f"  {rec}")

        except Exception as e:
            print(f"テスト実行エラー: {e}")

        finally:
            if manager:
                await manager.cleanup()

        print("\n=== 脆弱性管理システムテスト完了 ===")

    asyncio.run(main())
