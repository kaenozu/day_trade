#!/usr/bin/env python3
"""
è„†å¼±æ€§ç®¡ç†ã‚·ã‚¹ãƒ†ãƒ 
Issue #419: ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£å¼·åŒ– - è„†å¼±æ€§ç®¡ç†ãƒ—ãƒ­ã‚»ã‚¹ã®ç¢ºç«‹

ä¾å­˜é–¢ä¿‚ã‚¹ã‚­ãƒ£ãƒ³ã€è„†å¼±æ€§ãƒˆãƒªã‚¢ãƒ¼ã‚¸ã€ä¿®æ­£è¿½è·¡ã€
ãƒªã‚¹ã‚¯è©•ä¾¡ã‚’çµ±åˆã—ãŸåŒ…æ‹¬çš„è„†å¼±æ€§ç®¡ç†ã‚·ã‚¹ãƒ†ãƒ 
"""

import asyncio
import json
import logging
import time
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from datetime import datetime, timedelta
from enum import Enum, IntEnum
from pathlib import Path
from typing import Any, Dict, List, Optional

try:
    from ..utils.logging_config import get_context_logger
except ImportError:
    logging.basicConfig(level=logging.INFO)

    def get_context_logger(name):
        return logging.getLogger(name)


logger = get_context_logger(__name__)


class VulnerabilitySeverity(IntEnum):
    """è„†å¼±æ€§é‡è¦åº¦"""

    CRITICAL = 4
    HIGH = 3
    MEDIUM = 2
    LOW = 1
    INFORMATIONAL = 0


class VulnerabilityStatus(Enum):
    """è„†å¼±æ€§ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹"""

    DETECTED = "detected"
    TRIAGED = "triaged"
    ASSIGNED = "assigned"
    IN_PROGRESS = "in_progress"
    FIXED = "fixed"
    VERIFIED = "verified"
    CLOSED = "closed"
    IGNORED = "ignored"
    FALSE_POSITIVE = "false_positive"


class ScannerType(Enum):
    """ã‚¹ã‚­ãƒ£ãƒŠãƒ¼ã‚¿ã‚¤ãƒ—"""

    PIP_AUDIT = "pip-audit"
    SAFETY = "safety"
    BANDIT = "bandit"
    SEMGREP = "semgrep"
    SNYK = "snyk"
    CUSTOM = "custom"


@dataclass
class VulnerabilityInfo:
    """è„†å¼±æ€§æƒ…å ±"""

    # åŸºæœ¬æƒ…å ±
    vulnerability_id: str
    cve_id: Optional[str] = None
    title: str = ""
    description: str = ""

    # é‡è¦åº¦ãƒ»åˆ†é¡
    severity: VulnerabilitySeverity = VulnerabilitySeverity.MEDIUM
    cvss_score: Optional[float] = None
    cwe_id: Optional[str] = None

    # å½±éŸ¿ç¯„å›²
    affected_package: str = ""
    affected_versions: List[str] = field(default_factory=list)
    fixed_versions: List[str] = field(default_factory=list)

    # æ¤œå‡ºæƒ…å ±
    scanner_type: ScannerType = ScannerType.CUSTOM
    detected_at: datetime = field(default_factory=datetime.utcnow)
    file_path: Optional[str] = None
    line_number: Optional[int] = None

    # ç®¡ç†æƒ…å ±
    status: VulnerabilityStatus = VulnerabilityStatus.DETECTED
    assigned_to: Optional[str] = None
    due_date: Optional[datetime] = None

    # è¿½è·¡æƒ…å ±
    created_at: datetime = field(default_factory=datetime.utcnow)
    updated_at: datetime = field(default_factory=datetime.utcnow)
    resolution_notes: str = ""

    # ãƒªã‚¹ã‚¯è©•ä¾¡
    exploitability: str = "unknown"  # unknown, low, medium, high
    impact_assessment: str = ""
    business_risk: str = "unknown"  # low, medium, high, critical

    def to_dict(self) -> Dict[str, Any]:
        """è¾æ›¸å½¢å¼å¤‰æ›"""
        return {
            "vulnerability_id": self.vulnerability_id,
            "cve_id": self.cve_id,
            "title": self.title,
            "description": self.description,
            "severity": self.severity.name,
            "cvss_score": self.cvss_score,
            "cwe_id": self.cwe_id,
            "affected_package": self.affected_package,
            "affected_versions": self.affected_versions,
            "fixed_versions": self.fixed_versions,
            "scanner_type": self.scanner_type.value,
            "detected_at": self.detected_at.isoformat(),
            "file_path": self.file_path,
            "line_number": self.line_number,
            "status": self.status.value,
            "assigned_to": self.assigned_to,
            "due_date": self.due_date.isoformat() if self.due_date else None,
            "created_at": self.created_at.isoformat(),
            "updated_at": self.updated_at.isoformat(),
            "resolution_notes": self.resolution_notes,
            "exploitability": self.exploitability,
            "impact_assessment": self.impact_assessment,
            "business_risk": self.business_risk,
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "VulnerabilityInfo":
        """è¾æ›¸ã‹ã‚‰å¾©å…ƒ"""
        return cls(
            vulnerability_id=data["vulnerability_id"],
            cve_id=data.get("cve_id"),
            title=data.get("title", ""),
            description=data.get("description", ""),
            severity=VulnerabilitySeverity[data.get("severity", "MEDIUM")],
            cvss_score=data.get("cvss_score"),
            cwe_id=data.get("cwe_id"),
            affected_package=data.get("affected_package", ""),
            affected_versions=data.get("affected_versions", []),
            fixed_versions=data.get("fixed_versions", []),
            scanner_type=ScannerType(data.get("scanner_type", "custom")),
            detected_at=(
                datetime.fromisoformat(data["detected_at"])
                if data.get("detected_at")
                else datetime.utcnow()
            ),
            file_path=data.get("file_path"),
            line_number=data.get("line_number"),
            status=VulnerabilityStatus(data.get("status", "detected")),
            assigned_to=data.get("assigned_to"),
            due_date=datetime.fromisoformat(data["due_date"]) if data.get("due_date") else None,
            created_at=(
                datetime.fromisoformat(data["created_at"])
                if data.get("created_at")
                else datetime.utcnow()
            ),
            updated_at=(
                datetime.fromisoformat(data["updated_at"])
                if data.get("updated_at")
                else datetime.utcnow()
            ),
            resolution_notes=data.get("resolution_notes", ""),
            exploitability=data.get("exploitability", "unknown"),
            impact_assessment=data.get("impact_assessment", ""),
            business_risk=data.get("business_risk", "unknown"),
        )


class VulnerabilityScanner(ABC):
    """è„†å¼±æ€§ã‚¹ã‚­ãƒ£ãƒŠãƒ¼åŸºåº•ã‚¯ãƒ©ã‚¹"""

    @abstractmethod
    async def scan(self, target_path: str) -> List[VulnerabilityInfo]:
        """è„†å¼±æ€§ã‚¹ã‚­ãƒ£ãƒ³å®Ÿè¡Œ"""
        pass

    @abstractmethod
    def get_scanner_type(self) -> ScannerType:
        """ã‚¹ã‚­ãƒ£ãƒŠãƒ¼ã‚¿ã‚¤ãƒ—å–å¾—"""
        pass


class PipAuditScanner(VulnerabilityScanner):
    """pip-auditè„†å¼±æ€§ã‚¹ã‚­ãƒ£ãƒŠãƒ¼"""

    def __init__(self):
        self.scanner_type = ScannerType.PIP_AUDIT

    async def scan(self, target_path: str) -> List[VulnerabilityInfo]:
        """pip-auditã‚¹ã‚­ãƒ£ãƒ³å®Ÿè¡Œ"""
        try:
            # pip-auditå®Ÿè¡Œ
            process = await asyncio.create_subprocess_exec(
                "pip-audit",
                "--format=json",
                "--desc",
                cwd=target_path,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE,
            )

            stdout, stderr = await process.communicate()

            if process.returncode != 0:
                logger.warning(f"pip-auditå®Ÿè¡Œã‚¨ãƒ©ãƒ¼: {stderr.decode()}")
                return []

            # JSONè§£æ
            audit_results = json.loads(stdout.decode())

            vulnerabilities = []
            for vuln in audit_results.get("vulnerabilities", []):
                vuln_info = VulnerabilityInfo(
                    vulnerability_id=f"pip-audit-{vuln.get('id', 'unknown')}",
                    cve_id=vuln.get("id"),
                    title=f"Vulnerability in {vuln.get('package', 'unknown')}",
                    description=vuln.get("description", ""),
                    affected_package=vuln.get("package", ""),
                    affected_versions=[vuln.get("installed_version", "")],
                    fixed_versions=vuln.get("fixed_versions", []),
                    scanner_type=self.scanner_type,
                    severity=self._map_severity(vuln.get("vulnerability_description", "")),
                )
                vulnerabilities.append(vuln_info)

            return vulnerabilities

        except Exception as e:
            logger.error(f"pip-auditã‚¹ã‚­ãƒ£ãƒ³ã‚¨ãƒ©ãƒ¼: {e}")
            return []

    def _map_severity(self, description: str) -> VulnerabilitySeverity:
        """é‡è¦åº¦ãƒãƒƒãƒ”ãƒ³ã‚°"""
        description_lower = description.lower()
        if any(
            word in description_lower
            for word in ["critical", "remote code execution", "privilege escalation"]
        ):
            return VulnerabilitySeverity.CRITICAL
        elif any(word in description_lower for word in ["high", "denial of service", "injection"]):
            return VulnerabilitySeverity.HIGH
        elif any(word in description_lower for word in ["medium", "information disclosure"]):
            return VulnerabilitySeverity.MEDIUM
        else:
            return VulnerabilitySeverity.LOW

    def get_scanner_type(self) -> ScannerType:
        return self.scanner_type


class SafetyScanner(VulnerabilityScanner):
    """safetyè„†å¼±æ€§ã‚¹ã‚­ãƒ£ãƒŠãƒ¼"""

    def __init__(self):
        self.scanner_type = ScannerType.SAFETY

    async def scan(self, target_path: str) -> List[VulnerabilityInfo]:
        """safetyã‚¹ã‚­ãƒ£ãƒ³å®Ÿè¡Œ"""
        try:
            # safetyå®Ÿè¡Œ
            process = await asyncio.create_subprocess_exec(
                "safety",
                "check",
                "--json",
                "--short-report",
                cwd=target_path,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE,
            )

            stdout, stderr = await process.communicate()

            # safety ã¯è„†å¼±æ€§ãŒè¦‹ã¤ã‹ã£ãŸå ´åˆã«éã‚¼ãƒ­çµ‚äº†ã‚³ãƒ¼ãƒ‰ã‚’è¿”ã™ã®ã§ã€
            # ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ã‚’èª¿æ•´
            if stdout:
                try:
                    safety_results = json.loads(stdout.decode())
                except json.JSONDecodeError:
                    # JSONå½¢å¼ã§ãªã„å ´åˆã¯ãƒ†ã‚­ã‚¹ãƒˆè§£æ
                    return self._parse_text_output(stdout.decode())
            else:
                return []

            vulnerabilities = []
            for vuln in safety_results:
                vuln_info = VulnerabilityInfo(
                    vulnerability_id=f"safety-{vuln.get('advisory', 'unknown')}",
                    cve_id=vuln.get("advisory"),
                    title=f"Vulnerability in {vuln.get('package_name', 'unknown')}",
                    description=vuln.get("vulnerability", ""),
                    affected_package=vuln.get("package_name", ""),
                    affected_versions=[vuln.get("installed_version", "")],
                    scanner_type=self.scanner_type,
                    severity=VulnerabilitySeverity.HIGH,  # safetyã¯ä¸€èˆ¬çš„ã«é‡è¦ãªè„†å¼±æ€§ã‚’æ¤œå‡º
                )
                vulnerabilities.append(vuln_info)

            return vulnerabilities

        except Exception as e:
            logger.error(f"safetyã‚¹ã‚­ãƒ£ãƒ³ã‚¨ãƒ©ãƒ¼: {e}")
            return []

    def _parse_text_output(self, output: str) -> List[VulnerabilityInfo]:
        """ãƒ†ã‚­ã‚¹ãƒˆå‡ºåŠ›ã®è§£æ"""
        vulnerabilities = []
        lines = output.strip().split("\n")

        for line in lines:
            if "vulnerability" in line.lower() and "==" in line:
                parts = line.split("==")
                if len(parts) >= 2:
                    package_name = parts[0].strip()
                    vuln_info = VulnerabilityInfo(
                        vulnerability_id=f"safety-{package_name}-{int(time.time())}",
                        title=f"Vulnerability in {package_name}",
                        description=line.strip(),
                        affected_package=package_name,
                        scanner_type=self.scanner_type,
                        severity=VulnerabilitySeverity.HIGH,
                    )
                    vulnerabilities.append(vuln_info)

        return vulnerabilities

    def get_scanner_type(self) -> ScannerType:
        return self.scanner_type


class BanditScanner(VulnerabilityScanner):
    """bandité™çš„è§£æã‚¹ã‚­ãƒ£ãƒŠãƒ¼"""

    def __init__(self):
        self.scanner_type = ScannerType.BANDIT

    async def scan(self, target_path: str) -> List[VulnerabilityInfo]:
        """banditã‚¹ã‚­ãƒ£ãƒ³å®Ÿè¡Œ"""
        try:
            # banditå®Ÿè¡Œ
            process = await asyncio.create_subprocess_exec(
                "bandit",
                "-r",
                target_path,
                "-f",
                "json",
                "-q",
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE,
            )

            stdout, stderr = await process.communicate()

            if not stdout:
                return []

            try:
                bandit_results = json.loads(stdout.decode())
            except json.JSONDecodeError:
                logger.warning("banditå‡ºåŠ›ã®JSONè§£æã«å¤±æ•—")
                return []

            vulnerabilities = []
            for result in bandit_results.get("results", []):
                vuln_info = VulnerabilityInfo(
                    vulnerability_id=f"bandit-{result.get('test_id', 'unknown')}-{result.get('line_number', 0)}",
                    cve_id=result.get("test_id"),
                    title=result.get("test_name", ""),
                    description=result.get("issue_text", ""),
                    severity=self._map_bandit_severity(result.get("issue_severity", "MEDIUM")),
                    scanner_type=self.scanner_type,
                    file_path=result.get("filename"),
                    line_number=result.get("line_number"),
                    cwe_id=result.get("test_id"),
                )
                vulnerabilities.append(vuln_info)

            return vulnerabilities

        except Exception as e:
            logger.error(f"banditã‚¹ã‚­ãƒ£ãƒ³ã‚¨ãƒ©ãƒ¼: {e}")
            return []

    def _map_bandit_severity(self, severity: str) -> VulnerabilitySeverity:
        """bandité‡è¦åº¦ãƒãƒƒãƒ”ãƒ³ã‚°"""
        severity_map = {
            "HIGH": VulnerabilitySeverity.HIGH,
            "MEDIUM": VulnerabilitySeverity.MEDIUM,
            "LOW": VulnerabilitySeverity.LOW,
        }
        return severity_map.get(severity.upper(), VulnerabilitySeverity.MEDIUM)

    def get_scanner_type(self) -> ScannerType:
        return self.scanner_type


@dataclass
class ScanResult:
    """ã‚¹ã‚­ãƒ£ãƒ³çµæœ"""

    scan_id: str
    scan_type: ScannerType
    target_path: str
    start_time: datetime
    end_time: Optional[datetime] = None
    status: str = "running"  # running, completed, failed
    vulnerabilities: List[VulnerabilityInfo] = field(default_factory=list)
    error_message: Optional[str] = None

    def to_dict(self) -> Dict[str, Any]:
        return {
            "scan_id": self.scan_id,
            "scan_type": self.scan_type.value,
            "target_path": self.target_path,
            "start_time": self.start_time.isoformat(),
            "end_time": self.end_time.isoformat() if self.end_time else None,
            "status": self.status,
            "vulnerabilities": [v.to_dict() for v in self.vulnerabilities],
            "error_message": self.error_message,
        }


class VulnerabilityManager:
    """
    è„†å¼±æ€§ç®¡ç†ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼

    è¤‡æ•°ã®ã‚¹ã‚­ãƒ£ãƒŠãƒ¼ã‚’çµ±åˆã—ã€è„†å¼±æ€§ã®ãƒ©ã‚¤ãƒ•ã‚µã‚¤ã‚¯ãƒ«ç®¡ç†ã€
    ãƒˆãƒªã‚¢ãƒ¼ã‚¸ã€ä¿®æ­£è¿½è·¡ã‚’è¡Œã†ä¸­å¤®ç®¡ç†ã‚·ã‚¹ãƒ†ãƒ 
    """

    def __init__(
        self,
        storage_path: str = "security/vulnerabilities",
        scan_config_path: Optional[str] = None,
    ):
        """
        åˆæœŸåŒ–

        Args:
            storage_path: è„†å¼±æ€§ãƒ‡ãƒ¼ã‚¿ä¿å­˜ãƒ‘ã‚¹
            scan_config_path: ã‚¹ã‚­ãƒ£ãƒ³è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹
        """
        self.storage_path = Path(storage_path)
        self.storage_path.mkdir(parents=True, exist_ok=True)

        # ã‚¹ã‚­ãƒ£ãƒŠãƒ¼ç™»éŒ²
        self.scanners: Dict[ScannerType, VulnerabilityScanner] = {
            ScannerType.PIP_AUDIT: PipAuditScanner(),
            ScannerType.SAFETY: SafetyScanner(),
            ScannerType.BANDIT: BanditScanner(),
        }

        # è„†å¼±æ€§ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ï¼ˆãƒ¡ãƒ¢ãƒªï¼‰
        self.vulnerabilities: Dict[str, VulnerabilityInfo] = {}
        self.scan_results: Dict[str, ScanResult] = {}

        # è¨­å®š
        self.scan_config = self._load_scan_config(scan_config_path)

        # è‡ªå‹•ä¿®æ­£è¨­å®š
        self.auto_fix_enabled = self.scan_config.get("auto_fix_enabled", False)

        # ãƒ‡ãƒ¼ã‚¿èª­ã¿è¾¼ã¿
        self._load_vulnerabilities()

        logger.info("VulnerabilityManageråˆæœŸåŒ–å®Œäº†")

    def _load_scan_config(self, config_path: Optional[str]) -> Dict[str, Any]:
        """ã‚¹ã‚­ãƒ£ãƒ³è¨­å®šèª­ã¿è¾¼ã¿"""
        default_config = {
            "enabled_scanners": ["pip-audit", "safety", "bandit"],
            "scan_schedule": {"daily": True, "weekly_full_scan": True},
            "severity_thresholds": {
                "critical_sla_hours": 4,
                "high_sla_hours": 24,
                "medium_sla_hours": 168,  # 1é€±é–“
                "low_sla_hours": 720,  # 30æ—¥
            },
            "auto_fix_enabled": False,
            "notification_channels": ["console", "file"],
            "exclude_patterns": ["test_*", "*_test.py", "demo_*", "example_*"],
        }

        if config_path and Path(config_path).exists():
            try:
                with open(config_path, encoding="utf-8") as f:
                    loaded_config = json.load(f)
                default_config.update(loaded_config)
            except Exception as e:
                logger.warning(f"è¨­å®šèª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼: {e}")

        return default_config

    def _load_vulnerabilities(self):
        """ä¿å­˜ã•ã‚ŒãŸè„†å¼±æ€§ãƒ‡ãƒ¼ã‚¿èª­ã¿è¾¼ã¿"""
        vuln_file = self.storage_path / "vulnerabilities.json"
        if vuln_file.exists():
            try:
                with open(vuln_file, encoding="utf-8") as f:
                    data = json.load(f)

                for vuln_id, vuln_data in data.get("vulnerabilities", {}).items():
                    self.vulnerabilities[vuln_id] = VulnerabilityInfo.from_dict(vuln_data)

                logger.info(f"è„†å¼±æ€§ãƒ‡ãƒ¼ã‚¿èª­ã¿è¾¼ã¿å®Œäº†: {len(self.vulnerabilities)}ä»¶")

            except Exception as e:
                logger.error(f"è„†å¼±æ€§ãƒ‡ãƒ¼ã‚¿èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼: {e}")

    def _save_vulnerabilities(self):
        """è„†å¼±æ€§ãƒ‡ãƒ¼ã‚¿ä¿å­˜"""
        vuln_file = self.storage_path / "vulnerabilities.json"
        try:
            data = {
                "vulnerabilities": {
                    vuln_id: vuln.to_dict() for vuln_id, vuln in self.vulnerabilities.items()
                },
                "last_updated": datetime.utcnow().isoformat(),
            }

            with open(vuln_file, "w", encoding="utf-8") as f:
                json.dump(data, f, indent=2, ensure_ascii=False)

        except Exception as e:
            logger.error(f"è„†å¼±æ€§ãƒ‡ãƒ¼ã‚¿ä¿å­˜ã‚¨ãƒ©ãƒ¼: {e}")

    async def run_comprehensive_scan(
        self, target_path: str, scanner_types: Optional[List[ScannerType]] = None
    ) -> Dict[ScannerType, ScanResult]:
        """åŒ…æ‹¬çš„è„†å¼±æ€§ã‚¹ã‚­ãƒ£ãƒ³å®Ÿè¡Œ"""
        logger.info(f"åŒ…æ‹¬çš„è„†å¼±æ€§ã‚¹ã‚­ãƒ£ãƒ³é–‹å§‹: {target_path}")

        if scanner_types is None:
            scanner_types = list(self.scanners.keys())

        scan_results = {}

        # ä¸¦åˆ—ã‚¹ã‚­ãƒ£ãƒ³å®Ÿè¡Œ
        tasks = []
        for scanner_type in scanner_types:
            if scanner_type in self.scanners:
                task = self._run_single_scan(scanner_type, target_path)
                tasks.append(task)

        # ã‚¹ã‚­ãƒ£ãƒ³å®Ÿè¡Œ
        results = await asyncio.gather(*tasks, return_exceptions=True)

        # çµæœå‡¦ç†
        for i, result in enumerate(results):
            scanner_type = scanner_types[i]
            if isinstance(result, Exception):
                logger.error(f"ã‚¹ã‚­ãƒ£ãƒ³ã‚¨ãƒ©ãƒ¼ {scanner_type}: {result}")
            else:
                scan_results[scanner_type] = result
                # è„†å¼±æ€§ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹æ›´æ–°
                self._merge_scan_results(result)

        # ãƒ‡ãƒ¼ã‚¿ä¿å­˜
        self._save_vulnerabilities()

        logger.info(f"åŒ…æ‹¬çš„ã‚¹ã‚­ãƒ£ãƒ³å®Œäº†: {len(scan_results)}ä»¶ã®ã‚¹ã‚­ãƒ£ãƒ³çµæœ")
        return scan_results

    async def _run_single_scan(self, scanner_type: ScannerType, target_path: str) -> ScanResult:
        """å˜ä¸€ã‚¹ã‚­ãƒ£ãƒŠãƒ¼å®Ÿè¡Œ"""
        scan_id = f"{scanner_type.value}-{int(time.time())}"
        start_time = datetime.utcnow()

        scan_result = ScanResult(
            scan_id=scan_id,
            scan_type=scanner_type,
            target_path=target_path,
            start_time=start_time,
        )

        try:
            scanner = self.scanners[scanner_type]
            vulnerabilities = await scanner.scan(target_path)

            scan_result.vulnerabilities = vulnerabilities
            scan_result.status = "completed"
            scan_result.end_time = datetime.utcnow()

            logger.info(f"{scanner_type.value}ã‚¹ã‚­ãƒ£ãƒ³å®Œäº†: {len(vulnerabilities)}ä»¶ã®è„†å¼±æ€§æ¤œå‡º")

        except Exception as e:
            scan_result.status = "failed"
            scan_result.error_message = str(e)
            scan_result.end_time = datetime.utcnow()
            logger.error(f"{scanner_type.value}ã‚¹ã‚­ãƒ£ãƒ³å¤±æ•—: {e}")

        self.scan_results[scan_id] = scan_result
        return scan_result

    def _merge_scan_results(self, scan_result: ScanResult):
        """ã‚¹ã‚­ãƒ£ãƒ³çµæœã‚’ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã«ãƒãƒ¼ã‚¸"""
        for vuln in scan_result.vulnerabilities:
            existing_vuln = self.vulnerabilities.get(vuln.vulnerability_id)

            if existing_vuln:
                # æ—¢å­˜è„†å¼±æ€§ã®æ›´æ–°
                existing_vuln.updated_at = datetime.utcnow()
                existing_vuln.detected_at = vuln.detected_at
                # ä»–ã®æƒ…å ±ã‚‚å¿…è¦ã«å¿œã˜ã¦æ›´æ–°
            else:
                # æ–°è¦è„†å¼±æ€§
                vuln.status = VulnerabilityStatus.DETECTED
                self.vulnerabilities[vuln.vulnerability_id] = vuln

                # è‡ªå‹•ãƒˆãƒªã‚¢ãƒ¼ã‚¸å®Ÿè¡Œ
                self._auto_triage_vulnerability(vuln)

    def _auto_triage_vulnerability(self, vuln: VulnerabilityInfo):
        """è„†å¼±æ€§è‡ªå‹•ãƒˆãƒªã‚¢ãƒ¼ã‚¸"""
        # é‡è¦åº¦ã«åŸºã¥ãæœŸé™è¨­å®š
        severity_sla = self.scan_config["severity_thresholds"]

        if vuln.severity == VulnerabilitySeverity.CRITICAL:
            vuln.due_date = datetime.utcnow() + timedelta(hours=severity_sla["critical_sla_hours"])
        elif vuln.severity == VulnerabilitySeverity.HIGH:
            vuln.due_date = datetime.utcnow() + timedelta(hours=severity_sla["high_sla_hours"])
        elif vuln.severity == VulnerabilitySeverity.MEDIUM:
            vuln.due_date = datetime.utcnow() + timedelta(hours=severity_sla["medium_sla_hours"])
        else:
            vuln.due_date = datetime.utcnow() + timedelta(hours=severity_sla["low_sla_hours"])

        # è‡ªå‹•åˆ†é¡
        if vuln.severity in [
            VulnerabilitySeverity.CRITICAL,
            VulnerabilitySeverity.HIGH,
        ]:
            vuln.status = VulnerabilityStatus.TRIAGED

        logger.info(f"è„†å¼±æ€§è‡ªå‹•ãƒˆãƒªã‚¢ãƒ¼ã‚¸å®Œäº†: {vuln.vulnerability_id} ({vuln.severity.name})")

    def get_vulnerability_summary(self) -> Dict[str, Any]:
        """è„†å¼±æ€§ã‚µãƒãƒªãƒ¼å–å¾—"""
        summary = {
            "total_vulnerabilities": len(self.vulnerabilities),
            "by_severity": {},
            "by_status": {},
            "by_scanner": {},
            "overdue_count": 0,
            "critical_open": 0,
        }

        now = datetime.utcnow()

        for vuln in self.vulnerabilities.values():
            # é‡è¦åº¦åˆ¥
            severity_name = vuln.severity.name
            summary["by_severity"][severity_name] = summary["by_severity"].get(severity_name, 0) + 1

            # ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹åˆ¥
            status_name = vuln.status.value
            summary["by_status"][status_name] = summary["by_status"].get(status_name, 0) + 1

            # ã‚¹ã‚­ãƒ£ãƒŠãƒ¼åˆ¥
            scanner_name = vuln.scanner_type.value
            summary["by_scanner"][scanner_name] = summary["by_scanner"].get(scanner_name, 0) + 1

            # æœŸé™è¶…éãƒã‚§ãƒƒã‚¯
            if (
                vuln.due_date
                and now > vuln.due_date
                and vuln.status
                not in [
                    VulnerabilityStatus.FIXED,
                    VulnerabilityStatus.VERIFIED,
                    VulnerabilityStatus.CLOSED,
                ]
            ):
                summary["overdue_count"] += 1

            # é‡è¦ãªæœªè§£æ±ºå•é¡Œ
            if vuln.severity == VulnerabilitySeverity.CRITICAL and vuln.status not in [
                VulnerabilityStatus.FIXED,
                VulnerabilityStatus.VERIFIED,
                VulnerabilityStatus.CLOSED,
            ]:
                summary["critical_open"] += 1

        return summary

    def get_vulnerabilities_by_severity(
        self, severity: VulnerabilitySeverity, include_resolved: bool = False
    ) -> List[VulnerabilityInfo]:
        """é‡è¦åº¦åˆ¥è„†å¼±æ€§å–å¾—"""
        filtered_vulnerabilities = []

        for vuln in self.vulnerabilities.values():
            if vuln.severity == severity:
                if include_resolved or vuln.status not in [
                    VulnerabilityStatus.FIXED,
                    VulnerabilityStatus.VERIFIED,
                    VulnerabilityStatus.CLOSED,
                ]:
                    filtered_vulnerabilities.append(vuln)

        # æ¤œå‡ºæ—¥æ™‚ã§ã‚½ãƒ¼ãƒˆï¼ˆæ–°ã—ã„é †ï¼‰
        filtered_vulnerabilities.sort(key=lambda x: x.detected_at, reverse=True)

        return filtered_vulnerabilities

    def update_vulnerability_status(
        self,
        vulnerability_id: str,
        new_status: VulnerabilityStatus,
        notes: str = "",
        assigned_to: Optional[str] = None,
    ) -> bool:
        """è„†å¼±æ€§ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹æ›´æ–°"""
        vuln = self.vulnerabilities.get(vulnerability_id)
        if not vuln:
            logger.error(f"è„†å¼±æ€§ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“: {vulnerability_id}")
            return False

        old_status = vuln.status
        vuln.status = new_status
        vuln.updated_at = datetime.utcnow()

        if notes:
            vuln.resolution_notes = notes

        if assigned_to:
            vuln.assigned_to = assigned_to

        logger.info(
            f"è„†å¼±æ€§ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹æ›´æ–°: {vulnerability_id} {old_status.value} -> {new_status.value}"
        )

        # ãƒ‡ãƒ¼ã‚¿ä¿å­˜
        self._save_vulnerabilities()

        return True

    async def generate_security_report(self) -> Dict[str, Any]:
        """ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ¬ãƒãƒ¼ãƒˆç”Ÿæˆ"""
        logger.info("ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ¬ãƒãƒ¼ãƒˆç”Ÿæˆé–‹å§‹")

        summary = self.get_vulnerability_summary()

        # é‡è¦åº¦åˆ¥è©³ç´°
        severity_details = {}
        for severity in VulnerabilitySeverity:
            vulnerabilities = self.get_vulnerabilities_by_severity(severity)
            severity_details[severity.name] = {
                "count": len(vulnerabilities),
                "vulnerabilities": [
                    {
                        "id": v.vulnerability_id,
                        "title": v.title,
                        "package": v.affected_package,
                        "status": v.status.value,
                        "detected_at": v.detected_at.isoformat(),
                        "due_date": v.due_date.isoformat() if v.due_date else None,
                    }
                    for v in vulnerabilities[:10]  # ä¸Šä½10ä»¶ã®ã¿
                ],
            }

        # ã‚¹ã‚­ãƒ£ãƒ³å±¥æ­´
        recent_scans = sorted(self.scan_results.values(), key=lambda x: x.start_time, reverse=True)[
            :10
        ]

        scan_history = [
            {
                "scan_id": scan.scan_id,
                "scanner_type": scan.scan_type.value,
                "start_time": scan.start_time.isoformat(),
                "status": scan.status,
                "vulnerabilities_found": len(scan.vulnerabilities),
            }
            for scan in recent_scans
        ]

        report = {
            "report_id": f"security-report-{int(time.time())}",
            "generated_at": datetime.utcnow().isoformat(),
            "summary": summary,
            "severity_details": severity_details,
            "scan_history": scan_history,
            "recommendations": self._generate_recommendations(summary),
        }

        # ãƒ¬ãƒãƒ¼ãƒˆä¿å­˜
        report_file = self.storage_path / f"security_report_{int(time.time())}.json"
        with open(report_file, "w", encoding="utf-8") as f:
            json.dump(report, f, indent=2, ensure_ascii=False)

        logger.info(f"ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ¬ãƒãƒ¼ãƒˆç”Ÿæˆå®Œäº†: {report_file}")

        return report

    def _generate_recommendations(self, summary: Dict[str, Any]) -> List[str]:
        """æ¨å¥¨äº‹é …ç”Ÿæˆ"""
        recommendations = []

        if summary["critical_open"] > 0:
            recommendations.append(
                f"ğŸš¨ {summary['critical_open']}ä»¶ã®é‡è¦ãªè„†å¼±æ€§ãŒæœªè§£æ±ºã§ã™ã€‚ç›´ã¡ã«å¯¾å¿œã—ã¦ãã ã•ã„ã€‚"
            )

        if summary["overdue_count"] > 0:
            recommendations.append(
                f"â° {summary['overdue_count']}ä»¶ã®è„†å¼±æ€§ãŒæœŸé™ã‚’éãã¦ã„ã¾ã™ã€‚å„ªå…ˆçš„ã«å¯¾å¿œã—ã¦ãã ã•ã„ã€‚"
            )

        if summary["by_severity"].get("HIGH", 0) > 5:
            recommendations.append(
                "ğŸ” é«˜é‡è¦åº¦ã®è„†å¼±æ€§ãŒå¤šæ•°æ¤œå‡ºã•ã‚Œã¦ã„ã¾ã™ã€‚ä¾å­˜é–¢ä¿‚ã®æ›´æ–°ã‚’æ¤œè¨ã—ã¦ãã ã•ã„ã€‚"
            )

        if summary["total_vulnerabilities"] == 0:
            recommendations.append(
                "âœ… è„†å¼±æ€§ã¯æ¤œå‡ºã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚å®šæœŸçš„ãªã‚¹ã‚­ãƒ£ãƒ³ã‚’ç¶™ç¶šã—ã¦ãã ã•ã„ã€‚"
            )
        else:
            recommendations.append(
                "ğŸ”„ å®šæœŸçš„ãªä¾å­˜é–¢ä¿‚ã®æ›´æ–°ã¨ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚¹ã‚­ãƒ£ãƒ³ã‚’å®Ÿè¡Œã—ã¦ãã ã•ã„ã€‚"
            )

        return recommendations

    async def cleanup(self):
        """ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—"""
        logger.info("VulnerabilityManager ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—é–‹å§‹")

        # æœ€çµ‚ãƒ‡ãƒ¼ã‚¿ä¿å­˜
        self._save_vulnerabilities()

        logger.info("ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—å®Œäº†")


# Factory function
def create_vulnerability_manager(
    storage_path: str = "security/vulnerabilities",
    scan_config_path: Optional[str] = None,
) -> VulnerabilityManager:
    """VulnerabilityManagerãƒ•ã‚¡ã‚¯ãƒˆãƒªé–¢æ•°"""
    return VulnerabilityManager(storage_path=storage_path, scan_config_path=scan_config_path)


if __name__ == "__main__":
    # ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ
    async def main():
        print("=== Issue #419 è„†å¼±æ€§ç®¡ç†ã‚·ã‚¹ãƒ†ãƒ ãƒ†ã‚¹ãƒˆ ===")

        manager = None
        try:
            # è„†å¼±æ€§ç®¡ç†ã‚·ã‚¹ãƒ†ãƒ åˆæœŸåŒ–
            manager = create_vulnerability_manager()

            print("\n1. åŒ…æ‹¬çš„è„†å¼±æ€§ã‚¹ã‚­ãƒ£ãƒ³å®Ÿè¡Œ")
            target_path = "."

            scan_results = await manager.run_comprehensive_scan(target_path)

            print(f"ã‚¹ã‚­ãƒ£ãƒ³å®Œäº†: {len(scan_results)}ç¨®é¡ã®ã‚¹ã‚­ãƒ£ãƒŠãƒ¼ã‚’å®Ÿè¡Œ")
            for scanner_type, result in scan_results.items():
                print(f"  {scanner_type.value}: {len(result.vulnerabilities)}ä»¶ã®è„†å¼±æ€§æ¤œå‡º")

            print("\n2. è„†å¼±æ€§ã‚µãƒãƒªãƒ¼")
            summary = manager.get_vulnerability_summary()
            print(f"ç·è„†å¼±æ€§æ•°: {summary['total_vulnerabilities']}ä»¶")

            if summary["by_severity"]:
                print("é‡è¦åº¦åˆ¥:")
                for severity, count in summary["by_severity"].items():
                    print(f"  {severity}: {count}ä»¶")

            if summary["by_status"]:
                print("ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹åˆ¥:")
                for status, count in summary["by_status"].items():
                    print(f"  {status}: {count}ä»¶")

            print(f"æœŸé™è¶…é: {summary['overdue_count']}ä»¶")
            print(f"é‡è¦ãªæœªè§£æ±º: {summary['critical_open']}ä»¶")

            print("\n3. é‡è¦åº¦åˆ¥è©³ç´°")
            for severity in [
                VulnerabilitySeverity.CRITICAL,
                VulnerabilitySeverity.HIGH,
            ]:
                vulnerabilities = manager.get_vulnerabilities_by_severity(severity)
                if vulnerabilities:
                    print(f"\n{severity.name}é‡è¦åº¦ ({len(vulnerabilities)}ä»¶):")
                    for vuln in vulnerabilities[:3]:  # ä¸Šä½3ä»¶è¡¨ç¤º
                        print(f"  - {vuln.title}")
                        print(f"    ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸: {vuln.affected_package}")
                        print(f"    ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹: {vuln.status.value}")

            print("\n4. ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ¬ãƒãƒ¼ãƒˆç”Ÿæˆ")
            report = await manager.generate_security_report()
            print(f"ãƒ¬ãƒãƒ¼ãƒˆID: {report['report_id']}")
            print(f"æ¨å¥¨äº‹é …æ•°: {len(report['recommendations'])}")

            if report["recommendations"]:
                print("æ¨å¥¨äº‹é …:")
                for rec in report["recommendations"]:
                    print(f"  {rec}")

        except Exception as e:
            print(f"ãƒ†ã‚¹ãƒˆå®Ÿè¡Œã‚¨ãƒ©ãƒ¼: {e}")

        finally:
            if manager:
                await manager.cleanup()

        print("\n=== è„†å¼±æ€§ç®¡ç†ã‚·ã‚¹ãƒ†ãƒ ãƒ†ã‚¹ãƒˆå®Œäº† ===")

    asyncio.run(main())
