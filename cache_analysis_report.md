# キャッシュシステム分析レポート
**Issue #324: Cache Strategy Optimization**

---

## 🔍 現在のキャッシュシステム分析

### 検出されたキャッシュメカニズム

1. **DataCache (stock_fetcher.py)**
   - **用途**: API呼び出し結果のキャッシュ
   - **実装**: LRUキャッシュ + TTL
   - **容量**: 設定可能 (デフォルト1000)
   - **TTL**: 設定可能
   - **特徴**: Stale-while-revalidate サポート

2. **MemoryEfficientCache (memory_efficient_pipeline.py)**
   - **用途**: データパイプライン処理結果
   - **実装**: メモリ管理付きLRUキャッシュ
   - **容量**: メモリベース (256MB)
   - **特徴**: メモリ使用量監視、ガベージコレクション

3. **Model Cache (advanced_ml_engine.py)**
   - **用途**: ML モデルの永続化
   - **実装**: SQLite データベース
   - **特徴**: ディスク永続化、モデルバージョニング

4. **LSTM Model Cache (lstm_time_series_model.py)**
   - **用途**: LSTM モデルとスケーラー
   - **実装**: ファイルベース
   - **特徴**: ディレクトリ構造、モデル履歴

5. **OptimizedMLEngine Simple Cache**
   - **用途**: 技術指標計算結果
   - **実装**: 辞書ベース簡易キャッシュ
   - **容量**: 固定 (10エントリ)
   - **特徴**: ハッシュベースキー、自動クリア

---

## ⚠️ 現在の問題点

### 1. 分散化による非効率性
- **複数の独立したキャッシュシステム**
  - メモリ使用量の重複
  - キャッシュヒット率の低下
  - 管理の複雑さ

### 2. 容量管理の不一致
```python
# 異なる容量管理方式
DataCache: max_size=1000      # エントリ数ベース
MemoryEfficientCache: 256MB   # メモリベース
OptimizedMLEngine: 10         # 固定小サイズ
```

### 3. TTL戦略の不統一
```python
price_cache_ttl: 30秒         # 価格データ
historical_cache_ttl: 300秒   # 履歴データ
# ML計算結果: TTLなし（永続的）
```

### 4. キャッシュキーの非統一
- ハッシュベースキー vs 文字列キー
- 命名規則の不一致
- 衝突リスクの存在

---

## 📋 最適化戦略

### 1. 階層化キャッシュアーキテクチャ

```
┌─────────────────────────────────────┐
│          L1: Hot Cache              │
│     (メモリ内、超高速アクセス)        │
│           容量: 64MB                │
│            TTL: 30秒                │
└─────────────────────────────────────┘
                    ↓
┌─────────────────────────────────────┐
│          L2: Warm Cache             │
│      (メモリ内、高速アクセス)         │
│           容量: 256MB               │
│            TTL: 5分                 │
└─────────────────────────────────────┘
                    ↓
┌─────────────────────────────────────┐
│          L3: Cold Cache             │
│       (ディスク、永続ストレージ)      │
│           容量: 1GB                 │
│            TTL: 1日                 │
└─────────────────────────────────────┘
```

### 2. データ種別別最適化

| データタイプ | L1 | L2 | L3 | TTL戦略 |
|-------------|----|----|----| --------|
| **リアルタイム価格** | ✓ | ✓ | ✗ | 30秒 |
| **技術指標** | ✓ | ✓ | ✓ | 5分 |
| **ML予測結果** | ✓ | ✓ | ✓ | 10分 |
| **履歴データ** | ✗ | ✓ | ✓ | 1時間 |
| **モデル** | ✗ | ✗ | ✓ | 1日 |

### 3. 統合キーイング戦略

```python
def generate_unified_cache_key(
    component: str,
    operation: str,
    symbol: str,
    params: dict = None,
    timestamp_precision: str = "minute"
) -> str:
    """統一キー生成"""
    key_parts = [
        component,          # "ml_engine", "stock_fetcher"
        operation,          # "technical_indicators", "price"
        symbol,            # "7203", "9984"
        hash(str(params)) if params else "default",
        get_time_bucket(timestamp_precision)
    ]
    return ":".join(key_parts)
```

---

## 🚀 最適化実装計画

### Phase 1: 統合キャッシュマネージャー
- 全システム共通のキャッシュインターフェース
- 階層化アクセス制御
- 統一メトリクス収集

### Phase 2: 高度な退避戦略
- LRU + LFU ハイブリッド
- 重要度ベース優先順位
- プリフェッチ機能

### Phase 3: パフォーマンス最適化
- 並列キャッシュアクセス
- バックグラウンド更新
- 圧縮ストレージ

---

## 📊 期待効果

### メモリ効率化
- **現在**: 500MB以上の分散キャッシュ
- **最適化後**: 320MB統合キャッシュ
- **削減効果**: 35%以上

### アクセス速度向上
- **L1ヒット率**: 85%以上 (目標)
- **平均応答時間**: 50%短縮
- **スループット**: 2倍向上

### 運用効率化
- 統一管理インターフェース
- 自動容量調整
- 予測的事前ロード

---

## 🎯 優先実装項目

1. **UnifiedCacheManager** (高優先度)
   - 全コンポーネント共通インターフェース
   - 階層化アクセス制御

2. **SmartEvictionPolicy** (中優先度)
   - LRU + LFU + 重要度ベース
   - 予測的退避

3. **PredictivePreloader** (低優先度)
   - 使用パターン学習
   - 事前キャッシュロード

---

**分析日時**: 2025-08-08 19:25:00  
**対象コンポーネント**: 20+ キャッシュ実装  
**次のステップ**: UnifiedCacheManager設計・実装
