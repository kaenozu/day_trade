"""
Signalsモジュールの高度な機能テスト - 未カバー領域対応
"""

from decimal import Decimal
from unittest.mock import Mock, patch

import numpy as np
import pandas as pd
import pytest

from src.day_trade.analysis.signals import (
    SignalStrength,
    SignalType,
    TradingSignal,
    TradingSignalGenerator,
)
from src.day_trade.config.config_manager import ConfigManager


class TestTradingSignalAdvanced:
    """TradingSignalGeneratorの高度な機能テスト"""

    @pytest.fixture
    def sample_data(self):
        """テスト用の価格データ"""
        dates = pd.date_range("2023-01-01", periods=100, freq="D")
        np.random.seed(42)
        prices = 100 + np.cumsum(np.random.randn(100) * 0.5)

        df = pd.DataFrame({
            "Date": dates,
            "Open": prices * 0.99,
            "High": prices * 1.02,
            "Low": prices * 0.98,
            "Close": prices,
            "Volume": np.random.randint(1000, 10000, 100)
        })
        df.set_index("Date", inplace=True)
        return df

    @pytest.fixture
    def mock_config(self):
        """モックConfigManager"""
        mock_config = Mock()
        # 通常のgetメソッドの設定
        mock_config.get.return_value = {
            "signal_generation_settings": {
                "strength_multipliers": {
                    "strong": 1.2,
                    "medium": 1.0,
                    "weak": 0.8
                },
                "validation_adjustments": {
                    "multi_condition_bonus": 1.15,
                    "volatile_market_penalty": 0.85,
                    "trend_continuation_penalty": 0.85,
                    "performance_multipliers": {
                        "base": 0.6,
                        "high": 1.3,
                        "medium": 1.0,
                        "low": 0.7
                    }
                }
            }
        }
        return mock_config

    @pytest.fixture
    def signal_generator(self, mock_config):
        """TradingSignalGeneratorインスタンス"""
        return TradingSignalGenerator(config_path=None)

    def testvalidate_signal_with_strength_multipliers(self, signal_generator, sample_data):
        """信頼度計算で強度調整係数のテスト"""
        # STRONG信号の作成
        signal = TradingSignal(
            signal_type=SignalType.BUY,
            strength=SignalStrength.STRONG,
            confidence=80.0,
            reasons=["RSI oversold", "MA crossover", "Volume spike"],
            conditions_met={"rsi_oversold": True, "ma_crossover": True, "volume_spike": True},
            timestamp=sample_data.index[-1],
            price=Decimal("100.0")
        )

        # market_contextを提供して信頼度計算をテスト
        market_context = {
            "volatility": 0.01,  # 低ボラティリティ
            "trend_direction": "upward"
        }

        confidence = signal_generator.validate_signal(
            signal, market_context=market_context
        )

        # STRONG信号は1.2倍、3つの条件でボーナス、トレンドフォローでさらに調整
        assert confidence > signal.confidence
        assert isinstance(confidence, float)

    def testvalidate_signal_with_weak_signal(self, signal_generator):
        """WEAK信号での信頼度計算テスト"""
        signal = TradingSignal(
            signal_type=SignalType.SELL,
            strength=SignalStrength.WEAK,
            confidence=0.6,
            timestamp=pd.Timestamp.now(),
            conditions_met={"rsi_overbought": True}
        )

        confidence = signal_generator.validate_signal(signal)

        # WEAK信号は0.8倍される
        expected_base = signal.confidence * 0.8
        assert abs(confidence - expected_base) < 0.1

    def testvalidate_signal_with_volatile_market(self, signal_generator):
        """高ボラティリティ市場での信頼度計算テスト"""
        signal = TradingSignal(
            signal_type=SignalType.BUY,
            strength=SignalStrength.MEDIUM,
            confidence=0.7,
            timestamp=pd.Timestamp.now(),
            conditions_met={"ma_crossover": True}
        )

        # 高ボラティリティ市場
        market_context = {
            "volatility": 0.05,  # 閾値(0.02)を超える
            "trend_direction": "neutral"
        }

        confidence = signal_generator.validate_signal(
            signal, market_context=market_context
        )

        # 高ボラティリティでペナルティが適用される
        assert confidence < signal.confidence

    def testvalidate_signal_trend_following(self, signal_generator):
        """トレンドフォローシグナルの信頼度計算テスト"""
        # 上昇トレンドでのBUYシグナル
        signal = TradingSignal(
            signal_type=SignalType.BUY,
            strength=SignalStrength.MEDIUM,
            confidence=0.7,
            timestamp=pd.Timestamp.now(),
            conditions_met={"trend_following": True}
        )

        market_context = {
            "volatility": 0.01,
            "trend_direction": "upward"
        }

        confidence = signal_generator.validate_signal(
            signal, market_context=market_context
        )

        # トレンドフォローで1.1倍のボーナス
        assert confidence > signal.confidence * 1.05

    def testvalidate_signal_trend_reversal_penalty(self, signal_generator):
        """トレンド逆張りシグナルのペナルティテスト"""
        # 上昇トレンドでのSELLシグナル（逆張り）
        signal = TradingSignal(
            signal_type=SignalType.SELL,
            strength=SignalStrength.MEDIUM,
            confidence=0.7,
            timestamp=pd.Timestamp.now(),
            conditions_met={"reversal_signal": True}
        )

        market_context = {
            "volatility": 0.01,
            "trend_direction": "upward"
        }

        confidence = signal_generator.validate_signal(
            signal, market_context=market_context
        )

        # トレンド逆張りでペナルティが適用される
        assert confidence < signal.confidence * 0.9

    def testvalidate_signal_with_historical_performance(self, signal_generator):
        """過去パフォーマンスデータによる信頼度調整テスト"""
        signal = TradingSignal(
            signal_type=SignalType.BUY,
            strength=SignalStrength.MEDIUM,
            confidence=0.7,
            timestamp=pd.Timestamp.now(),
            conditions_met={"historical_test": True}
        )

        # 成功データありの履歴
        historical_performance = pd.DataFrame({
            "Signal": ["buy", "buy", "sell", "buy"],
            "Success": [True, True, False, True],
            "Strength": ["strong", "medium", "weak", "strong"]
        })

        confidence = signal_generator.validate_signal(
            signal, historical_performance=historical_performance
        )

        # 過去の成功率が高いので信頼度が上がる
        assert isinstance(confidence, float)
        assert confidence >= 0.0

    def testvalidate_signal_with_historical_performance_no_success_column(self, signal_generator):
        """成功カラムなしの履歴データでの信頼度調整テスト"""
        signal = TradingSignal(
            signal_type=SignalType.BUY,
            strength=SignalStrength.MEDIUM,
            confidence=0.7,
            timestamp=pd.Timestamp.now(),
            conditions_met={"historical_test": True}
        )

        # Successカラムなしの履歴
        historical_performance = pd.DataFrame({
            "Signal": ["buy", "buy", "sell"],
            "Strength": ["strong", "medium", "weak"]
        })

        confidence = signal_generator.validate_signal(
            signal, historical_performance=historical_performance
        )

        # 強度ベースの成功率計算が使用される
        assert isinstance(confidence, float)
        assert confidence >= 0.0

    def testvalidate_signal_multi_condition_bonus(self, signal_generator):
        """複数条件ボーナスのテスト"""
        # 3つの条件を満たすシグナル
        signal_multi = TradingSignal(
            signal_type=SignalType.BUY,
            strength=SignalStrength.MEDIUM,
            confidence=0.7,
            timestamp=pd.Timestamp.now(),
            conditions_met={
                "rsi_oversold": True,
                "ma_crossover": True,
                "volume_spike": True
            }
        )

        confidence_multi = signal_generator.validate_signal(signal_multi)

        # 2つの条件を満たすシグナル
        signal_two = TradingSignal(
            signal_type=SignalType.BUY,
            strength=SignalStrength.MEDIUM,
            confidence=0.7,
            timestamp=pd.Timestamp.now(),
            conditions_met={
                "rsi_oversold": True,
                "ma_crossover": True
            }
        )

        confidence_two = signal_generator.validate_signal(signal_two)

        # 3条件の方がボーナスが大きい
        assert confidence_multi > confidence_two

    def testvalidate_signal_empty_historical_performance(self, signal_generator):
        """空の履歴データでの信頼度計算テスト"""
        signal = TradingSignal(
            signal_type=SignalType.BUY,
            strength=SignalStrength.MEDIUM,
            confidence=0.7,
            timestamp=pd.Timestamp.now(),
            conditions_met={"test": True}
        )

        # 空のDataFrame
        empty_performance = pd.DataFrame()

        confidence = signal_generator.validate_signal(
            signal, historical_performance=empty_performance
        )

        # 履歴がない場合は基本的な計算のみ
        assert isinstance(confidence, float)
        assert confidence > 0.0


class TestTradingSignalGeneratorExtended:
    """TradingSignalGeneratorクラスのテスト"""

    @pytest.fixture
    def mock_config(self):
        """モックConfigManager"""
        mock_config = Mock(spec=ConfigManager)
        mock_config.get.return_value = {}
        return mock_config

    @pytest.fixture
    def extended_generator(self, mock_config):
        """TradingSignalGeneratorインスタンス"""
        return TradingSignalGenerator(config_path=None)

    def test_merge_conditions_safely_no_overlap(self, extended_generator):
        """条件結合でキー重複なしのテスト"""
        buy_conditions = {"rsi_oversold": True, "volume_high": False}
        sell_conditions = {"rsi_overbought": True, "momentum_negative": True}

        merged = extended_generator._merge_conditions_safely(buy_conditions, sell_conditions)

        expected = {
            "rsi_oversold": True,
            "volume_high": False,
            "rsi_overbought": True,
            "momentum_negative": True
        }

        assert merged == expected

    def test_merge_conditions_safely_with_overlap(self, extended_generator):
        """条件結合でキー重複ありのテスト"""
        buy_conditions = {"rsi_condition": True, "volume_high": False}
        sell_conditions = {"rsi_condition": False, "momentum_negative": True}

        with patch('src.day_trade.analysis.signals.logger') as mock_logger:
            merged = extended_generator._merge_conditions_safely(buy_conditions, sell_conditions)

            # 警告ログが出力されることを確認
            mock_logger.warning.assert_called_once()
            call_args = mock_logger.warning.call_args[0][0]
            assert "同名キーが検出されました" in call_args

        # 重複キーが適切に処理されることを確認
        assert "buy_rsi_condition" in merged
        assert "sell_rsi_condition" in merged
        assert "rsi_condition" not in merged
        assert merged["buy_rsi_condition"] is True
        assert merged["sell_rsi_condition"] is False
        assert merged["volume_high"] is False
        assert merged["momentum_negative"] is True

    def test_merge_conditions_safely_multiple_overlaps(self, extended_generator):
        """複数キー重複の条件結合テスト"""
        buy_conditions = {
            "rsi_condition": True,
            "ma_condition": False,
            "unique_buy": True
        }
        sell_conditions = {
            "rsi_condition": False,
            "ma_condition": True,
            "unique_sell": False
        }

        with patch('src.day_trade.analysis.signals.logger') as mock_logger:
            merged = extended_generator._merge_conditions_safely(buy_conditions, sell_conditions)

            # 警告ログが出力されることを確認
            mock_logger.warning.assert_called_once()

        # 全ての重複キーが適切に処理されることを確認
        assert "buy_rsi_condition" in merged
        assert "sell_rsi_condition" in merged
        assert "buy_ma_condition" in merged
        assert "sell_ma_condition" in merged
        assert "unique_buy" in merged
        assert "unique_sell" in merged

        # 元のキーが削除されていることを確認
        assert "rsi_condition" not in merged
        assert "ma_condition" not in merged

    def test_merge_conditions_safely_empty_conditions(self, extended_generator):
        """空の条件での結合テスト"""
        # 空の買い条件
        buy_conditions = {}
        sell_conditions = {"rsi_overbought": True}

        merged = extended_generator._merge_conditions_safely(buy_conditions, sell_conditions)
        assert merged == {"rsi_overbought": True}

        # 空の売り条件
        buy_conditions = {"rsi_oversold": True}
        sell_conditions = {}

        merged = extended_generator._merge_conditions_safely(buy_conditions, sell_conditions)
        assert merged == {"rsi_oversold": True}

        # 両方空
        buy_conditions = {}
        sell_conditions = {}

        merged = extended_generator._merge_conditions_safely(buy_conditions, sell_conditions)
        assert merged == {}


class TestSignalValidationAdvanced:
    """シグナル検証の高度な機能テスト"""

    @pytest.fixture
    def sample_data(self):
        """テスト用データ"""
        dates = pd.date_range("2023-01-01", periods=50, freq="D")
        np.random.seed(42)
        prices = 100 + np.cumsum(np.random.randn(50) * 0.3)

        return pd.DataFrame({
            "Date": dates,
            "Open": prices * 0.99,
            "High": prices * 1.01,
            "Low": prices * 0.98,
            "Close": prices,
            "Volume": np.random.randint(1000, 5000, 50)
        }).set_index("Date")

    @pytest.fixture
    def mock_config(self):
        """詳細設定のモックConfig"""
        mock_config = Mock(spec=ConfigManager)
        mock_config.get_high_volatility_threshold.return_value = 0.025
        mock_config.get.return_value = {
            "signal_generation_settings": {
                "strength_multipliers": {
                    "strong": 1.3,
                    "medium": 1.0,
                    "weak": 0.7
                },
                "validation_adjustments": {
                    "multi_condition_bonus": 1.2,
                    "volatile_market_penalty": 0.8,
                    "trend_continuation_penalty": 0.9,
                    "performance_multipliers": {
                        "base": 0.5,
                        "high": 1.4,
                        "medium": 1.0,
                        "low": 0.6
                    }
                }
            }
        }
        return mock_config

    @pytest.fixture
    def signal_generator(self, mock_config):
        """TradingSignalGeneratorインスタンス"""
        return TradingSignalGenerator(config_path=None)

    def test_complex_market_context_validation(self, signal_generator, sample_data):
        """複雑な市場環境での検証テスト"""
        generator = signal_generator

        # 複雑な市場状況を設定
        complex_market_context = {
            "volatility": 0.03,  # 高ボラティリティ
            "trend_direction": "downward",
            "volume_trend": "increasing",
            "market_regime": "volatile"
        }

        # 下降トレンドでのSELLシグナル（トレンドフォロー）
        sell_signal = TradingSignal(
            signal_type=SignalType.SELL,
            strength=SignalStrength.STRONG,
            confidence=0.85,
            timestamp=sample_data.index[-1],
            conditions_met={
                "trend_break": True,
                "volume_confirmation": True,
                "momentum_negative": True,
                "support_break": True
            }
        )

        confidence = generator.validate_signal(
            sell_signal, market_context=complex_market_context
        )

        # 高ボラティリティでペナルティ、但し4つの条件とトレンドフォローでボーナス
        assert isinstance(confidence, float)
        assert confidence > 0.0

    def test_performance_based_confidence_adjustment(self, signal_generator):
        """パフォーマンスベースの信頼度調整の詳細テスト"""
        generator = signal_generator

        signal = TradingSignal(
            signal_type=SignalType.BUY,
            strength=SignalStrength.MEDIUM,
            confidence=0.75,
            timestamp=pd.Timestamp.now(),
            conditions_met={"performance_test": True}
        )

        # 高成功率の履歴データ
        high_success_history = pd.DataFrame({
            "Signal": ["buy"] * 10,
            "Success": [True] * 8 + [False] * 2,  # 80%成功率
            "Strength": ["strong"] * 5 + ["medium"] * 3 + ["weak"] * 2
        })

        confidence_high = generator.validate_signal(
            signal, historical_performance=high_success_history
        )

        # 低成功率の履歴データ
        low_success_history = pd.DataFrame({
            "Signal": ["buy"] * 10,
            "Success": [True] * 2 + [False] * 8,  # 20%成功率
            "Strength": ["weak"] * 7 + ["medium"] * 2 + ["strong"] * 1
        })

        confidence_low = generator.validate_signal(
            signal, historical_performance=low_success_history
        )

        # 高成功率の方が信頼度が高くなることを確認
        assert confidence_high >= confidence_low


if __name__ == "__main__":
    pytest.main([__file__, "-v"])
