#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Realtime Alert & Notification System - ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ã‚¢ãƒ©ãƒ¼ãƒˆãƒ»é€šçŸ¥ã‚·ã‚¹ãƒ†ãƒ 

Issue #788å®Ÿè£…ï¼šãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ã‚¢ãƒ©ãƒ¼ãƒˆãƒ»é€šçŸ¥ã‚·ã‚¹ãƒ†ãƒ 
é‡è¦ãªå–å¼•æ©Ÿä¼šã‚„ãƒªã‚¹ã‚¯ã‚’å³åº§ã«é€šçŸ¥ã™ã‚‹ã‚¢ãƒ©ãƒ¼ãƒˆã‚·ã‚¹ãƒ†ãƒ 
"""

import asyncio
import pandas as pd
import numpy as np
import logging
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Tuple, Any, Union, Callable
from dataclasses import dataclass, field
from enum import Enum
import json
import sqlite3
from pathlib import Path
import smtplib
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
import time
import threading
from queue import Queue, Empty
import uuid

# Windowsç’°å¢ƒã§ã®æ–‡å­—åŒ–ã‘å¯¾ç­–
import sys
import os
os.environ['PYTHONIOENCODING'] = 'utf-8'

if sys.platform == 'win32':
    try:
        sys.stdout.reconfigure(encoding='utf-8')
        sys.stderr.reconfigure(encoding='utf-8')
    except:
        import codecs
        sys.stdout = codecs.getwriter('utf-8')(sys.stdout.buffer)
        sys.stderr = codecs.getwriter('utf-8')(sys.stderr.buffer)

class AlertPriority(Enum):
    """ã‚¢ãƒ©ãƒ¼ãƒˆå„ªå…ˆåº¦"""
    CRITICAL = "critical"
    HIGH = "high"
    MEDIUM = "medium"
    LOW = "low"
    INFO = "info"

class AlertType(Enum):
    """ã‚¢ãƒ©ãƒ¼ãƒˆã‚¿ã‚¤ãƒ—"""
    PRICE_ALERT = "price_alert"
    VOLUME_ALERT = "volume_alert"
    TECHNICAL_SIGNAL = "technical_signal"
    RISK_WARNING = "risk_warning"
    SYSTEM_ERROR = "system_error"
    TRADING_OPPORTUNITY = "trading_opportunity"
    MARKET_NEWS = "market_news"
    PERFORMANCE_UPDATE = "performance_update"

class NotificationChannel(Enum):
    """é€šçŸ¥ãƒãƒ£ãƒãƒ«"""
    CONSOLE = "console"
    EMAIL = "email"
    LOG_FILE = "log_file"
    DATABASE = "database"
    WEBHOOK = "webhook"
    DESKTOP = "desktop"

@dataclass
class AlertRule:
    """ã‚¢ãƒ©ãƒ¼ãƒˆãƒ«ãƒ¼ãƒ«"""
    rule_id: str
    name: str
    alert_type: AlertType
    condition: str  # Pythonå¼ã¨ã—ã¦è©•ä¾¡
    priority: AlertPriority
    enabled: bool = True
    cooldown_minutes: int = 5
    last_triggered: Optional[datetime] = None
    trigger_count: int = 0
    description: str = ""
    symbols: List[str] = field(default_factory=list)
    notification_channels: List[NotificationChannel] = field(default_factory=list)

@dataclass
class Alert:
    """ã‚¢ãƒ©ãƒ¼ãƒˆ"""
    alert_id: str
    rule_id: str
    alert_type: AlertType
    priority: AlertPriority
    symbol: str
    title: str
    message: str
    data: Dict[str, Any]
    timestamp: datetime
    acknowledged: bool = False
    resolved: bool = False

@dataclass
class NotificationConfig:
    """é€šçŸ¥è¨­å®š"""
    email_enabled: bool = False
    email_smtp_server: str = ""
    email_smtp_port: int = 587
    email_username: str = ""
    email_password: str = ""
    email_to_addresses: List[str] = field(default_factory=list)
    webhook_url: str = ""
    webhook_enabled: bool = False
    desktop_enabled: bool = True
    console_enabled: bool = True

class AlertConditionEvaluator:
    """ã‚¢ãƒ©ãƒ¼ãƒˆæ¡ä»¶è©•ä¾¡å™¨"""

    def __init__(self):
        self.logger = logging.getLogger(__name__)
        self.safe_globals = {
            '__builtins__': {},
            'abs': abs,
            'max': max,
            'min': min,
            'round': round,
            'len': len,
            'sum': sum,
            'any': any,
            'all': all,
            'np': np,
            'pd': pd
        }

    def evaluate_condition(self, condition: str, context: Dict[str, Any]) -> bool:
        """æ¡ä»¶è©•ä¾¡"""

        try:
            # å®‰å…¨ãªã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆä½œæˆ
            safe_context = {**self.safe_globals, **context}

            # æ¡ä»¶è©•ä¾¡
            result = eval(condition, safe_context, {})
            return bool(result)

        except Exception as e:
            self.logger.error(f"æ¡ä»¶è©•ä¾¡ã‚¨ãƒ©ãƒ¼: {condition} - {e}")
            return False

class NotificationManager:
    """é€šçŸ¥ç®¡ç†ã‚·ã‚¹ãƒ†ãƒ """

    def __init__(self, config: NotificationConfig):
        self.config = config
        self.logger = logging.getLogger(__name__)

    async def send_notification(self, alert: Alert, channels: List[NotificationChannel]):
        """é€šçŸ¥é€ä¿¡"""

        for channel in channels:
            try:
                if channel == NotificationChannel.CONSOLE and self.config.console_enabled:
                    await self._send_console_notification(alert)
                elif channel == NotificationChannel.EMAIL and self.config.email_enabled:
                    await self._send_email_notification(alert)
                elif channel == NotificationChannel.LOG_FILE:
                    await self._send_log_notification(alert)
                elif channel == NotificationChannel.DESKTOP and self.config.desktop_enabled:
                    await self._send_desktop_notification(alert)
                elif channel == NotificationChannel.WEBHOOK and self.config.webhook_enabled:
                    await self._send_webhook_notification(alert)

            except Exception as e:
                self.logger.error(f"é€šçŸ¥é€ä¿¡ã‚¨ãƒ©ãƒ¼ {channel}: {e}")

    async def _send_console_notification(self, alert: Alert):
        """ã‚³ãƒ³ã‚½ãƒ¼ãƒ«é€šçŸ¥"""

        priority_emoji = {
            AlertPriority.CRITICAL: "ğŸš¨",
            AlertPriority.HIGH: "âš ï¸",
            AlertPriority.MEDIUM: "ğŸ“¢",
            AlertPriority.LOW: "â„¹ï¸",
            AlertPriority.INFO: "ğŸ’¡"
        }

        emoji = priority_emoji.get(alert.priority, "ğŸ“¢")
        timestamp = alert.timestamp.strftime("%H:%M:%S")

        print(f"{emoji} [{timestamp}] {alert.symbol} - {alert.title}")
        print(f"   {alert.message}")

        if alert.priority in [AlertPriority.CRITICAL, AlertPriority.HIGH]:
            print("   " + "="*50)

    async def _send_email_notification(self, alert: Alert):
        """ãƒ¡ãƒ¼ãƒ«é€šçŸ¥"""

        if not self.config.email_to_addresses:
            return

        try:
            msg = MIMEMultipart()
            msg['From'] = self.config.email_username
            msg['To'] = ", ".join(self.config.email_to_addresses)
            msg['Subject'] = f"[{alert.priority.value.upper()}] {alert.symbol} - {alert.title}"

            body = f"""
ã‚¢ãƒ©ãƒ¼ãƒˆé€šçŸ¥

éŠ˜æŸ„: {alert.symbol}
å„ªå…ˆåº¦: {alert.priority.value.upper()}
ã‚¿ã‚¤ãƒ—: {alert.alert_type.value}
ã‚¿ã‚¤ãƒˆãƒ«: {alert.title}
ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸: {alert.message}
ç™ºç”Ÿæ™‚åˆ»: {alert.timestamp.strftime("%Y-%m-%d %H:%M:%S")}

è©³ç´°ãƒ‡ãƒ¼ã‚¿:
{json.dumps(alert.data, indent=2, ensure_ascii=False)}

---
ãƒ‡ã‚¤ãƒˆãƒ¬ãƒ¼ãƒ‰AIã‚·ã‚¹ãƒ†ãƒ 
"""

            msg.attach(MIMEText(body, 'plain', 'utf-8'))

            server = smtplib.SMTP(self.config.email_smtp_server, self.config.email_smtp_port)
            server.starttls()
            server.login(self.config.email_username, self.config.email_password)
            server.send_message(msg)
            server.quit()

            self.logger.info(f"ãƒ¡ãƒ¼ãƒ«é€šçŸ¥é€ä¿¡å®Œäº†: {alert.alert_id}")

        except Exception as e:
            self.logger.error(f"ãƒ¡ãƒ¼ãƒ«é€šçŸ¥ã‚¨ãƒ©ãƒ¼: {e}")

    async def _send_log_notification(self, alert: Alert):
        """ãƒ­ã‚°ãƒ•ã‚¡ã‚¤ãƒ«é€šçŸ¥"""

        log_level = {
            AlertPriority.CRITICAL: logging.CRITICAL,
            AlertPriority.HIGH: logging.ERROR,
            AlertPriority.MEDIUM: logging.WARNING,
            AlertPriority.LOW: logging.INFO,
            AlertPriority.INFO: logging.INFO
        }

        level = log_level.get(alert.priority, logging.INFO)
        message = f"[{alert.symbol}] {alert.title}: {alert.message}"

        self.logger.log(level, message)

    async def _send_desktop_notification(self, alert: Alert):
        """ãƒ‡ã‚¹ã‚¯ãƒˆãƒƒãƒ—é€šçŸ¥"""

        # Windowsç’°å¢ƒã§ã®ç°¡æ˜“å®Ÿè£…
        try:
            import win10toast
            toaster = win10toast.ToastNotifier()
            toaster.show_toast(
                f"{alert.symbol} - {alert.title}",
                alert.message,
                duration=10,
                threaded=True
            )
        except ImportError:
            self.logger.debug("ãƒ‡ã‚¹ã‚¯ãƒˆãƒƒãƒ—é€šçŸ¥ãƒ©ã‚¤ãƒ–ãƒ©ãƒªãŒåˆ©ç”¨ã§ãã¾ã›ã‚“")
        except Exception as e:
            self.logger.error(f"ãƒ‡ã‚¹ã‚¯ãƒˆãƒƒãƒ—é€šçŸ¥ã‚¨ãƒ©ãƒ¼: {e}")

    async def _send_webhook_notification(self, alert: Alert):
        """Webhooké€šçŸ¥"""

        if not self.config.webhook_url:
            return

        try:
            import requests

            payload = {
                'alert_id': alert.alert_id,
                'symbol': alert.symbol,
                'priority': alert.priority.value,
                'type': alert.alert_type.value,
                'title': alert.title,
                'message': alert.message,
                'timestamp': alert.timestamp.isoformat(),
                'data': alert.data
            }

            response = requests.post(
                self.config.webhook_url,
                json=payload,
                timeout=10
            )
            response.raise_for_status()

            self.logger.info(f"Webhooké€šçŸ¥é€ä¿¡å®Œäº†: {alert.alert_id}")

        except Exception as e:
            self.logger.error(f"Webhooké€šçŸ¥ã‚¨ãƒ©ãƒ¼: {e}")

class RealTimeAlertSystem:
    """ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ã‚¢ãƒ©ãƒ¼ãƒˆã‚·ã‚¹ãƒ†ãƒ """

    def __init__(self):
        self.logger = logging.getLogger(__name__)

        # ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹è¨­å®š
        self.db_path = Path("alert_data/alerts.db")
        self.db_path.parent.mkdir(exist_ok=True)

        # ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆåˆæœŸåŒ–
        self.condition_evaluator = AlertConditionEvaluator()

        # é€šçŸ¥è¨­å®šï¼ˆãƒ‡ãƒ•ã‚©ãƒ«ãƒˆï¼‰
        self.notification_config = NotificationConfig(
            console_enabled=True,
            desktop_enabled=True
        )
        self.notification_manager = NotificationManager(self.notification_config)

        # ã‚¢ãƒ©ãƒ¼ãƒˆç®¡ç†
        self.alert_rules: Dict[str, AlertRule] = {}
        self.active_alerts: Dict[str, Alert] = {}
        self.alert_queue = Queue()

        # ç›£è¦–å¯¾è±¡ãƒ‡ãƒ¼ã‚¿
        self.market_data: Dict[str, Dict[str, Any]] = {}

        # ã‚¹ãƒ¬ãƒƒãƒ‰ç®¡ç†
        self.monitoring_thread = None
        self.notification_thread = None
        self.is_running = False

        self._init_database()
        self._setup_default_rules()

        self.logger.info("Realtime alert system initialized")

    def _init_database(self):
        """ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹åˆæœŸåŒ–"""

        try:
            with sqlite3.connect(self.db_path) as conn:
                cursor = conn.cursor()

                # ã‚¢ãƒ©ãƒ¼ãƒˆãƒ«ãƒ¼ãƒ«ãƒ†ãƒ¼ãƒ–ãƒ«
                cursor.execute('''
                    CREATE TABLE IF NOT EXISTS alert_rules (
                        rule_id TEXT PRIMARY KEY,
                        name TEXT NOT NULL,
                        alert_type TEXT NOT NULL,
                        condition_text TEXT NOT NULL,
                        priority TEXT NOT NULL,
                        enabled INTEGER DEFAULT 1,
                        cooldown_minutes INTEGER DEFAULT 5,
                        last_triggered TEXT,
                        trigger_count INTEGER DEFAULT 0,
                        description TEXT,
                        symbols TEXT,
                        notification_channels TEXT,
                        created_at TEXT NOT NULL
                    )
                ''')

                # ã‚¢ãƒ©ãƒ¼ãƒˆå±¥æ­´ãƒ†ãƒ¼ãƒ–ãƒ«
                cursor.execute('''
                    CREATE TABLE IF NOT EXISTS alert_history (
                        alert_id TEXT PRIMARY KEY,
                        rule_id TEXT NOT NULL,
                        alert_type TEXT NOT NULL,
                        priority TEXT NOT NULL,
                        symbol TEXT NOT NULL,
                        title TEXT NOT NULL,
                        message TEXT NOT NULL,
                        data TEXT,
                        timestamp TEXT NOT NULL,
                        acknowledged INTEGER DEFAULT 0,
                        resolved INTEGER DEFAULT 0
                    )
                ''')

                conn.commit()

        except Exception as e:
            self.logger.error(f"ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹åˆæœŸåŒ–ã‚¨ãƒ©ãƒ¼: {e}")

    def _setup_default_rules(self):
        """ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆãƒ«ãƒ¼ãƒ«è¨­å®š"""

        # 1. ä¾¡æ ¼æ€¥å¤‰ã‚¢ãƒ©ãƒ¼ãƒˆ
        self.add_alert_rule(AlertRule(
            rule_id="price_spike",
            name="ä¾¡æ ¼æ€¥å¤‰ã‚¢ãƒ©ãƒ¼ãƒˆ",
            alert_type=AlertType.PRICE_ALERT,
            condition="abs(current_change) > 0.05",  # 5%ä»¥ä¸Šã®å¤‰å‹•
            priority=AlertPriority.HIGH,
            cooldown_minutes=15,
            description="5%ä»¥ä¸Šã®æ€¥æ¿€ãªä¾¡æ ¼å¤‰å‹•ã‚’æ¤œå‡º",
            notification_channels=[NotificationChannel.CONSOLE, NotificationChannel.LOG_FILE]
        ))

        # 2. å‡ºæ¥é«˜æ€¥å¢—ã‚¢ãƒ©ãƒ¼ãƒˆ
        self.add_alert_rule(AlertRule(
            rule_id="volume_surge",
            name="å‡ºæ¥é«˜æ€¥å¢—ã‚¢ãƒ©ãƒ¼ãƒˆ",
            alert_type=AlertType.VOLUME_ALERT,
            condition="volume_ratio > 3.0",  # å¹³å‡ã®3å€ä»¥ä¸Š
            priority=AlertPriority.MEDIUM,
            cooldown_minutes=30,
            description="é€šå¸¸ã®3å€ä»¥ä¸Šã®å‡ºæ¥é«˜ã‚’æ¤œå‡º",
            notification_channels=[NotificationChannel.CONSOLE]
        ))

        # 3. æŠ€è¡“çš„å£²è²·ã‚·ã‚°ãƒŠãƒ«
        self.add_alert_rule(AlertRule(
            rule_id="technical_signal",
            name="æŠ€è¡“çš„å£²è²·ã‚·ã‚°ãƒŠãƒ«",
            alert_type=AlertType.TECHNICAL_SIGNAL,
            condition="signal_strength > 75",  # å¼·ã„ã‚·ã‚°ãƒŠãƒ«
            priority=AlertPriority.MEDIUM,
            cooldown_minutes=60,
            description="å¼·ã„æŠ€è¡“çš„å£²è²·ã‚·ã‚°ãƒŠãƒ«ã‚’æ¤œå‡º",
            notification_channels=[NotificationChannel.CONSOLE, NotificationChannel.LOG_FILE]
        ))

        # 4. ãƒªã‚¹ã‚¯è­¦å‘Š
        self.add_alert_rule(AlertRule(
            rule_id="risk_warning",
            name="ãƒªã‚¹ã‚¯è­¦å‘Š",
            alert_type=AlertType.RISK_WARNING,
            condition="risk_score > 80 or volatility > 0.4",
            priority=AlertPriority.CRITICAL,
            cooldown_minutes=10,
            description="é«˜ãƒªã‚¹ã‚¯çŠ¶æ³ã‚’æ¤œå‡º",
            notification_channels=[NotificationChannel.CONSOLE, NotificationChannel.LOG_FILE]
        ))

        # 5. å–å¼•æ©Ÿä¼šã‚¢ãƒ©ãƒ¼ãƒˆ
        self.add_alert_rule(AlertRule(
            rule_id="trading_opportunity",
            name="å–å¼•æ©Ÿä¼šã‚¢ãƒ©ãƒ¼ãƒˆ",
            alert_type=AlertType.TRADING_OPPORTUNITY,
            condition="prediction_confidence > 0.8 and signal_consensus >= 0.7",
            priority=AlertPriority.HIGH,
            cooldown_minutes=30,
            description="é«˜ä¿¡é ¼åº¦ã®å–å¼•æ©Ÿä¼šã‚’æ¤œå‡º",
            notification_channels=[NotificationChannel.CONSOLE, NotificationChannel.LOG_FILE]
        ))

        # 6. ã‚·ã‚¹ãƒ†ãƒ ã‚¨ãƒ©ãƒ¼ã‚¢ãƒ©ãƒ¼ãƒˆ
        self.add_alert_rule(AlertRule(
            rule_id="system_error",
            name="ã‚·ã‚¹ãƒ†ãƒ ã‚¨ãƒ©ãƒ¼ã‚¢ãƒ©ãƒ¼ãƒˆ",
            alert_type=AlertType.SYSTEM_ERROR,
            condition="error_count > 0",
            priority=AlertPriority.CRITICAL,
            cooldown_minutes=5,
            description="ã‚·ã‚¹ãƒ†ãƒ ã‚¨ãƒ©ãƒ¼ã‚’æ¤œå‡º",
            notification_channels=[NotificationChannel.CONSOLE, NotificationChannel.LOG_FILE]
        ))

    def add_alert_rule(self, rule: AlertRule):
        """ã‚¢ãƒ©ãƒ¼ãƒˆãƒ«ãƒ¼ãƒ«è¿½åŠ """

        self.alert_rules[rule.rule_id] = rule

        # ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã«ä¿å­˜
        try:
            with sqlite3.connect(self.db_path) as conn:
                cursor = conn.cursor()

                cursor.execute('''
                    INSERT OR REPLACE INTO alert_rules
                    (rule_id, name, alert_type, condition_text, priority, enabled,
                     cooldown_minutes, last_triggered, trigger_count, description,
                     symbols, notification_channels, created_at)
                    VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
                ''', (
                    rule.rule_id,
                    rule.name,
                    rule.alert_type.value,
                    rule.condition,
                    rule.priority.value,
                    1 if rule.enabled else 0,
                    rule.cooldown_minutes,
                    rule.last_triggered.isoformat() if rule.last_triggered else None,
                    rule.trigger_count,
                    rule.description,
                    json.dumps(rule.symbols),
                    json.dumps([c.value for c in rule.notification_channels]),
                    datetime.now().isoformat()
                ))

                conn.commit()

        except Exception as e:
            self.logger.error(f"ãƒ«ãƒ¼ãƒ«ä¿å­˜ã‚¨ãƒ©ãƒ¼: {e}")

    def update_market_data(self, symbol: str, data: Dict[str, Any]):
        """å¸‚å ´ãƒ‡ãƒ¼ã‚¿æ›´æ–°"""

        self.market_data[symbol] = {
            **data,
            'timestamp': datetime.now(),
            'symbol': symbol
        }

    async def check_alert_conditions(self, symbol: str):
        """ã‚¢ãƒ©ãƒ¼ãƒˆæ¡ä»¶ãƒã‚§ãƒƒã‚¯"""

        if symbol not in self.market_data:
            return

        market_data = self.market_data[symbol]
        current_time = datetime.now()

        for rule in self.alert_rules.values():
            if not rule.enabled:
                continue

            # éŠ˜æŸ„ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼
            if rule.symbols and symbol not in rule.symbols:
                continue

            # ã‚¯ãƒ¼ãƒ«ãƒ€ã‚¦ãƒ³ãƒã‚§ãƒƒã‚¯
            if rule.last_triggered:
                time_since_last = current_time - rule.last_triggered
                if time_since_last.total_seconds() < rule.cooldown_minutes * 60:
                    continue

            try:
                # æ¡ä»¶è©•ä¾¡
                condition_met = self.condition_evaluator.evaluate_condition(
                    rule.condition, market_data
                )

                if condition_met:
                    await self._trigger_alert(rule, symbol, market_data)

            except Exception as e:
                self.logger.error(f"ã‚¢ãƒ©ãƒ¼ãƒˆæ¡ä»¶ãƒã‚§ãƒƒã‚¯ã‚¨ãƒ©ãƒ¼ {rule.rule_id}: {e}")

    async def _trigger_alert(self, rule: AlertRule, symbol: str, data: Dict[str, Any]):
        """ã‚¢ãƒ©ãƒ¼ãƒˆç™ºç«"""

        # ã‚¢ãƒ©ãƒ¼ãƒˆä½œæˆ
        alert = Alert(
            alert_id=str(uuid.uuid4()),
            rule_id=rule.rule_id,
            alert_type=rule.alert_type,
            priority=rule.priority,
            symbol=symbol,
            title=rule.name,
            message=self._generate_alert_message(rule, symbol, data),
            data=data,
            timestamp=datetime.now()
        )

        # ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã‚¢ãƒ©ãƒ¼ãƒˆã«è¿½åŠ 
        self.active_alerts[alert.alert_id] = alert

        # é€šçŸ¥ã‚­ãƒ¥ãƒ¼ã«è¿½åŠ 
        self.alert_queue.put((alert, rule.notification_channels))

        # ãƒ«ãƒ¼ãƒ«æ›´æ–°
        rule.last_triggered = datetime.now()
        rule.trigger_count += 1

        # ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã«ä¿å­˜
        await self._save_alert_to_db(alert)

        self.logger.info(f"ã‚¢ãƒ©ãƒ¼ãƒˆç™ºç«: {rule.name} - {symbol}")

    def _generate_alert_message(self, rule: AlertRule, symbol: str, data: Dict[str, Any]) -> str:
        """ã‚¢ãƒ©ãƒ¼ãƒˆãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ç”Ÿæˆ"""

        message_templates = {
            AlertType.PRICE_ALERT: f"{symbol}ã®ä¾¡æ ¼ãŒæ€¥å¤‰ã—ã¾ã—ãŸ",
            AlertType.VOLUME_ALERT: f"{symbol}ã®å‡ºæ¥é«˜ãŒæ€¥å¢—ã—ã¦ã„ã¾ã™",
            AlertType.TECHNICAL_SIGNAL: f"{symbol}ã§æŠ€è¡“çš„å£²è²·ã‚·ã‚°ãƒŠãƒ«ãŒç™ºç”Ÿ",
            AlertType.RISK_WARNING: f"{symbol}ã§é«˜ãƒªã‚¹ã‚¯çŠ¶æ³ã‚’æ¤œå‡º",
            AlertType.TRADING_OPPORTUNITY: f"{symbol}ã§å–å¼•æ©Ÿä¼šã‚’æ¤œå‡º",
            AlertType.SYSTEM_ERROR: f"ã‚·ã‚¹ãƒ†ãƒ ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ"
        }

        base_message = message_templates.get(rule.alert_type, rule.description)

        # ãƒ‡ãƒ¼ã‚¿ã«åŸºã¥ããƒ¡ãƒƒã‚»ãƒ¼ã‚¸å¼·åŒ–
        try:
            if 'current_price' in data:
                base_message += f" (ä¾¡æ ¼: {data['current_price']:.0f}å††)"
            if 'current_change' in data:
                change_pct = data['current_change'] * 100
                base_message += f" (å¤‰å‹•ç‡: {change_pct:+.2f}%)"
            if 'volume_ratio' in data:
                base_message += f" (å‡ºæ¥é«˜æ¯”: {data['volume_ratio']:.1f}å€)"
        except:
            pass

        return base_message

    async def _save_alert_to_db(self, alert: Alert):
        """ã‚¢ãƒ©ãƒ¼ãƒˆã‚’ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã«ä¿å­˜"""

        try:
            with sqlite3.connect(self.db_path) as conn:
                cursor = conn.cursor()

                cursor.execute('''
                    INSERT INTO alert_history
                    (alert_id, rule_id, alert_type, priority, symbol, title,
                     message, data, timestamp, acknowledged, resolved)
                    VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
                ''', (
                    alert.alert_id,
                    alert.rule_id,
                    alert.alert_type.value,
                    alert.priority.value,
                    alert.symbol,
                    alert.title,
                    alert.message,
                    json.dumps(alert.data, ensure_ascii=False, default=str),
                    alert.timestamp.isoformat(),
                    1 if alert.acknowledged else 0,
                    1 if alert.resolved else 0
                ))

                conn.commit()

        except Exception as e:
            self.logger.error(f"ã‚¢ãƒ©ãƒ¼ãƒˆä¿å­˜ã‚¨ãƒ©ãƒ¼: {e}")

    def start_monitoring(self):
        """ç›£è¦–é–‹å§‹"""

        if self.is_running:
            return

        self.is_running = True

        # é€šçŸ¥å‡¦ç†ã‚¹ãƒ¬ãƒƒãƒ‰é–‹å§‹
        self.notification_thread = threading.Thread(target=self._notification_worker, daemon=True)
        self.notification_thread.start()

        self.logger.info("ã‚¢ãƒ©ãƒ¼ãƒˆç›£è¦–é–‹å§‹")

    def stop_monitoring(self):
        """ç›£è¦–åœæ­¢"""

        self.is_running = False
        self.logger.info("ã‚¢ãƒ©ãƒ¼ãƒˆç›£è¦–åœæ­¢")

    def _notification_worker(self):
        """é€šçŸ¥ãƒ¯ãƒ¼ã‚«ãƒ¼"""

        while self.is_running:
            try:
                # ã‚­ãƒ¥ãƒ¼ã‹ã‚‰é€šçŸ¥ã‚’å–å¾—
                alert, channels = self.alert_queue.get(timeout=1.0)

                # éåŒæœŸã§é€šçŸ¥é€ä¿¡
                asyncio.create_task(
                    self.notification_manager.send_notification(alert, channels)
                )

                self.alert_queue.task_done()

            except Empty:
                continue
            except Exception as e:
                self.logger.error(f"é€šçŸ¥ãƒ¯ãƒ¼ã‚«ãƒ¼ã‚¨ãƒ©ãƒ¼: {e}")

    def acknowledge_alert(self, alert_id: str):
        """ã‚¢ãƒ©ãƒ¼ãƒˆç¢ºèª"""

        if alert_id in self.active_alerts:
            self.active_alerts[alert_id].acknowledged = True
            self.logger.info(f"ã‚¢ãƒ©ãƒ¼ãƒˆç¢ºèª: {alert_id}")

    def resolve_alert(self, alert_id: str):
        """ã‚¢ãƒ©ãƒ¼ãƒˆè§£æ±º"""

        if alert_id in self.active_alerts:
            self.active_alerts[alert_id].resolved = True
            del self.active_alerts[alert_id]
            self.logger.info(f"ã‚¢ãƒ©ãƒ¼ãƒˆè§£æ±º: {alert_id}")

    def get_active_alerts(self) -> List[Alert]:
        """ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã‚¢ãƒ©ãƒ¼ãƒˆå–å¾—"""

        return list(self.active_alerts.values())

    def get_alert_statistics(self) -> Dict[str, Any]:
        """ã‚¢ãƒ©ãƒ¼ãƒˆçµ±è¨ˆå–å¾—"""

        try:
            with sqlite3.connect(self.db_path) as conn:
                cursor = conn.cursor()

                # ä»Šæ—¥ã®ã‚¢ãƒ©ãƒ¼ãƒˆæ•°
                today = datetime.now().date()
                cursor.execute('''
                    SELECT COUNT(*) FROM alert_history
                    WHERE date(timestamp) = ?
                ''', (today.isoformat(),))
                today_count = cursor.fetchone()[0]

                # å„ªå…ˆåº¦åˆ¥çµ±è¨ˆ
                cursor.execute('''
                    SELECT priority, COUNT(*) FROM alert_history
                    WHERE date(timestamp) >= date('now', '-7 days')
                    GROUP BY priority
                ''')
                priority_stats = dict(cursor.fetchall())

                # ã‚¿ã‚¤ãƒ—åˆ¥çµ±è¨ˆ
                cursor.execute('''
                    SELECT alert_type, COUNT(*) FROM alert_history
                    WHERE date(timestamp) >= date('now', '-7 days')
                    GROUP BY alert_type
                ''')
                type_stats = dict(cursor.fetchall())

                return {
                    'active_alerts': len(self.active_alerts),
                    'today_alerts': today_count,
                    'priority_stats': priority_stats,
                    'type_stats': type_stats,
                    'total_rules': len(self.alert_rules),
                    'enabled_rules': len([r for r in self.alert_rules.values() if r.enabled])
                }

        except Exception as e:
            self.logger.error(f"çµ±è¨ˆå–å¾—ã‚¨ãƒ©ãƒ¼: {e}")
            return {}

# ã‚°ãƒ­ãƒ¼ãƒãƒ«ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹
realtime_alert_system = RealTimeAlertSystem()

# ãƒ†ã‚¹ãƒˆãƒ»ãƒ‡ãƒ¢å®Ÿè¡Œ
async def run_alert_system_test():
    """ã‚¢ãƒ©ãƒ¼ãƒˆã‚·ã‚¹ãƒ†ãƒ ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ"""

    print("=== ğŸ”” ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ã‚¢ãƒ©ãƒ¼ãƒˆãƒ»é€šçŸ¥ã‚·ã‚¹ãƒ†ãƒ ãƒ†ã‚¹ãƒˆ ===")

    # ç›£è¦–é–‹å§‹
    realtime_alert_system.start_monitoring()

    # ãƒ†ã‚¹ãƒˆãƒ‡ãƒ¼ã‚¿ã§ã‚¢ãƒ©ãƒ¼ãƒˆã‚’ãƒˆãƒªã‚¬ãƒ¼
    test_symbols = ["7203", "8306", "4751"]

    print(f"\nğŸ“Š ãƒ†ã‚¹ãƒˆã‚¢ãƒ©ãƒ¼ãƒˆç”Ÿæˆ:")

    for i, symbol in enumerate(test_symbols, 1):
        print(f"\n--- ãƒ†ã‚¹ãƒˆ {i}: {symbol} ---")

        # 1. ä¾¡æ ¼æ€¥å¤‰ãƒ†ã‚¹ãƒˆ
        realtime_alert_system.update_market_data(symbol, {
            'current_price': 3000,
            'current_change': 0.08,  # 8%å¤‰å‹•
            'volume_ratio': 2.5,
            'signal_strength': 0,
            'risk_score': 30,
            'volatility': 0.2,
            'prediction_confidence': 0.6,
            'signal_consensus': 0.5,
            'error_count': 0
        })

        await realtime_alert_system.check_alert_conditions(symbol)
        await asyncio.sleep(0.5)

        # 2. å‡ºæ¥é«˜æ€¥å¢—ãƒ†ã‚¹ãƒˆ
        realtime_alert_system.update_market_data(symbol, {
            'current_price': 3000,
            'current_change': 0.02,
            'volume_ratio': 4.5,  # 4.5å€ã®å‡ºæ¥é«˜
            'signal_strength': 0,
            'risk_score': 30,
            'volatility': 0.2,
            'prediction_confidence': 0.6,
            'signal_consensus': 0.5,
            'error_count': 0
        })

        await realtime_alert_system.check_alert_conditions(symbol)
        await asyncio.sleep(0.5)

        # 3. å–å¼•æ©Ÿä¼šãƒ†ã‚¹ãƒˆ
        realtime_alert_system.update_market_data(symbol, {
            'current_price': 3000,
            'current_change': 0.02,
            'volume_ratio': 1.5,
            'signal_strength': 80,  # å¼·ã„ã‚·ã‚°ãƒŠãƒ«
            'risk_score': 30,
            'volatility': 0.2,
            'prediction_confidence': 0.85,  # é«˜ä¿¡é ¼åº¦
            'signal_consensus': 0.8,  # é«˜åˆæ„åº¦
            'error_count': 0
        })

        await realtime_alert_system.check_alert_conditions(symbol)
        await asyncio.sleep(0.5)

        # 4. ãƒªã‚¹ã‚¯è­¦å‘Šãƒ†ã‚¹ãƒˆ
        realtime_alert_system.update_market_data(symbol, {
            'current_price': 3000,
            'current_change': 0.02,
            'volume_ratio': 1.5,
            'signal_strength': 50,
            'risk_score': 85,  # é«˜ãƒªã‚¹ã‚¯
            'volatility': 0.45,  # é«˜ãƒœãƒ©ãƒ†ã‚£ãƒªãƒ†ã‚£
            'prediction_confidence': 0.6,
            'signal_consensus': 0.5,
            'error_count': 0
        })

        await realtime_alert_system.check_alert_conditions(symbol)
        await asyncio.sleep(0.5)

    # å°‘ã—å¾…ã£ã¦é€šçŸ¥å‡¦ç†ã‚’å®Œäº†
    await asyncio.sleep(2.0)

    # çµ±è¨ˆè¡¨ç¤º
    print(f"\nğŸ“ˆ ã‚¢ãƒ©ãƒ¼ãƒˆçµ±è¨ˆ:")
    stats = realtime_alert_system.get_alert_statistics()

    print(f"  ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã‚¢ãƒ©ãƒ¼ãƒˆ: {stats.get('active_alerts', 0)}")
    print(f"  æœ¬æ—¥ã®ã‚¢ãƒ©ãƒ¼ãƒˆ: {stats.get('today_alerts', 0)}")
    print(f"  ç·ãƒ«ãƒ¼ãƒ«æ•°: {stats.get('total_rules', 0)}")
    print(f"  æœ‰åŠ¹ãƒ«ãƒ¼ãƒ«æ•°: {stats.get('enabled_rules', 0)}")

    # ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã‚¢ãƒ©ãƒ¼ãƒˆè¡¨ç¤º
    active_alerts = realtime_alert_system.get_active_alerts()
    if active_alerts:
        print(f"\nğŸ”” ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã‚¢ãƒ©ãƒ¼ãƒˆä¸€è¦§:")
        for alert in active_alerts[:5]:  # ä¸Šä½5ä»¶
            print(f"  - {alert.symbol}: {alert.title} ({alert.priority.value})")

    # ç›£è¦–åœæ­¢
    realtime_alert_system.stop_monitoring()

    print(f"\nâœ… ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ã‚¢ãƒ©ãƒ¼ãƒˆãƒ»é€šçŸ¥ã‚·ã‚¹ãƒ†ãƒ ãƒ†ã‚¹ãƒˆå®Œäº†")

if __name__ == "__main__":
    # ãƒ­ã‚°è¨­å®š
    logging.basicConfig(level=logging.INFO, format='%(levelname)s: %(message)s')

    # ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ
    asyncio.run(run_alert_system_test())