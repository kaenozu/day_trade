name: Issue Triage Automation
on:
  issues:
    types: [opened, edited, labeled, reopened]
  schedule:
    - cron: '0 9 * * *'  # æ¯æ—¥9æ™‚ã«ãƒˆãƒªã‚¢ãƒ¼ã‚¸å®Ÿè¡Œ
  workflow_dispatch:  # æ‰‹å‹•å®Ÿè¡Œå¯èƒ½

jobs:
  triage-new-issues:
    runs-on: ubuntu-latest
    if: github.event_name == 'issues'
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Auto-label based on title and body
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const issue = context.payload.issue;
            const title = issue.title.toLowerCase();
            const body = issue.body?.toLowerCase() || '';

            const labels = [];
            const assignees = [];
            let priority = 'medium';
            let milestone = null;

            // ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£é–¢é€£ã®è‡ªå‹•æ¤œå‡º
            if (title.includes('ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£') || title.includes('security') ||
                body.includes('è„†å¼±æ€§') || body.includes('vulnerability') ||
                title.includes('sqlã‚¤ãƒ³ã‚¸ã‚§ã‚¯ã‚·ãƒ§ãƒ³') || title.includes('toctou')) {
              labels.push('security', 'high-priority');
              priority = 'high';
              assignees.push('${{ github.repository_owner }}');
            }

            // ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–ã®æ¤œå‡º
            if (title.includes('æœ€é©åŒ–') || title.includes('optimization') ||
                title.includes('é«˜é€ŸåŒ–') || title.includes('performance') ||
                title.includes('åŠ¹ç‡åŒ–') || title.includes('efficiency')) {
              labels.push('performance', 'optimization');
            }

            // æ©Ÿæ¢°å­¦ç¿’é–¢é€£
            if (title.includes('æ©Ÿæ¢°å­¦ç¿’') || title.includes('ml') || title.includes('ai') ||
                title.includes('ç‰¹å¾´é‡') || title.includes('feature') ||
                title.includes('ãƒ¢ãƒ‡ãƒ«') || title.includes('model')) {
              labels.push('machine-learning', 'feature');
            }

            // ãƒ‡ãƒ¼ã‚¿å‡¦ç†é–¢é€£
            if (title.includes('ãƒ‡ãƒ¼ã‚¿') || title.includes('data') ||
                title.includes('i/o') || title.includes('ã‚­ãƒ£ãƒƒã‚·ãƒ¥') ||
                title.includes('ãƒãƒƒãƒ') || title.includes('batch')) {
              labels.push('data-processing');
            }

            // ãƒ†ã‚¹ãƒˆé–¢é€£
            if (title.includes('ãƒ†ã‚¹ãƒˆ') || title.includes('test') ||
                title.includes('ãƒ¢ãƒƒã‚¯') || title.includes('mock')) {
              labels.push('testing', 'dev-experience');
            }

            // ä¸¦åˆ—å‡¦ç†é–¢é€£
            if (title.includes('ä¸¦åˆ—') || title.includes('parallel') ||
                title.includes('åˆ†æ•£') || title.includes('distributed') ||
                title.includes('concurrent')) {
              labels.push('parallel-processing', 'performance');
            }

            // ãƒãƒƒã‚¯ãƒ†ã‚¹ãƒˆé–¢é€£
            if (title.includes('ãƒãƒƒã‚¯ãƒ†ã‚¹ãƒˆ') || title.includes('backtest') ||
                title.includes('ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³') || title.includes('simulation')) {
              labels.push('backtesting', 'simulation');
            }

            // é«˜é »åº¦å–å¼•é–¢é€£
            if (title.includes('é«˜é »åº¦') || title.includes('hft') ||
                title.includes('ãƒã‚¤ã‚¯ãƒ­ç§’') || title.includes('microsecond') ||
                title.includes('è¶…é«˜é€Ÿ') || title.includes('ultra-fast')) {
              labels.push('hft', 'critical-performance', 'high-priority');
              priority = 'critical';
            }

            // ãƒã‚°ã®æ¤œå‡º
            if (title.includes('ãƒã‚°') || title.includes('bug') ||
                title.includes('ã‚¨ãƒ©ãƒ¼') || title.includes('error') ||
                title.includes('ä¿®æ­£') || title.includes('fix')) {
              labels.push('bug');
              if (title.includes('ã‚¯ãƒªãƒ†ã‚£ã‚«ãƒ«') || title.includes('critical')) {
                labels.push('critical');
                priority = 'critical';
              }
            }

            // æ–°æ©Ÿèƒ½
            if (title.includes('feat:') || title.includes('feature:') ||
                title.includes('æ–°æ©Ÿèƒ½') || title.includes('è¿½åŠ ')) {
              labels.push('enhancement', 'feature');
            }

            // è¤‡é›‘ã•ãƒ™ãƒ¼ã‚¹ã®å„ªå…ˆåº¦èª¿æ•´
            if (body.includes('phase') || body.includes('ãƒ•ã‚§ãƒ¼ã‚º') ||
                body.length > 1000) {
              labels.push('complex');
            }

            // ãƒ©ãƒ™ãƒ«ã®é©ç”¨
            if (labels.length > 0) {
              await github.rest.issues.setLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                labels: labels
              });
            }

            // æ‹…å½“è€…ã®è¨­å®š
            if (assignees.length > 0) {
              await github.rest.issues.addAssignees({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                assignees: assignees
              });
            }

            // å„ªå…ˆåº¦ã‚³ãƒ¡ãƒ³ãƒˆã®è¿½åŠ 
            let priorityComment = '';
            if (priority === 'critical') {
              priorityComment = 'ğŸš¨ **Critical Priority** - This issue requires immediate attention.\n\n';
            } else if (priority === 'high') {
              priorityComment = 'âš ï¸ **High Priority** - This issue should be addressed soon.\n\n';
            }

            if (priorityComment) {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                body: priorityComment + 'è‡ªå‹•ãƒˆãƒªã‚¢ãƒ¼ã‚¸ã«ã‚ˆã‚Šå„ªå…ˆåº¦ãŒè¨­å®šã•ã‚Œã¾ã—ãŸã€‚å¿…è¦ã«å¿œã˜ã¦èª¿æ•´ã—ã¦ãã ã•ã„ã€‚'
              });
            }

  triage-stale-issues:
    runs-on: ubuntu-latest
    if: github.event_name == 'schedule' || github.event_name == 'workflow_dispatch'
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Manage stale issues
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const { data: issues } = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              sort: 'updated',
              direction: 'asc',
              per_page: 100
            });

            const now = new Date();
            const thirtyDaysAgo = new Date(now.getTime() - (30 * 24 * 60 * 60 * 1000));
            const sevenDaysAgo = new Date(now.getTime() - (7 * 24 * 60 * 60 * 1000));

            for (const issue of issues) {
              const updatedAt = new Date(issue.updated_at);
              const hasStaleLabel = issue.labels.some(label => label.name === 'stale');
              const hasCriticalLabel = issue.labels.some(label =>
                ['critical', 'security', 'high-priority'].includes(label.name)
              );

              // ã‚¯ãƒªãƒ†ã‚£ã‚«ãƒ«ãªã‚¤ã‚·ãƒ¥ãƒ¼ã¯ stale ã«ã—ãªã„
              if (hasCriticalLabel) {
                continue;
              }

              if (updatedAt < thirtyDaysAgo && !hasStaleLabel) {
                // 30æ—¥é–“æ›´æ–°ãŒãªã„å ´åˆã¯ stale ãƒ©ãƒ™ãƒ«ã‚’è¿½åŠ 
                await github.rest.issues.addLabels({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issue.number,
                  labels: ['stale']
                });

                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issue.number,
                  body: 'ğŸ•’ ã“ã®ã‚¤ã‚·ãƒ¥ãƒ¼ã¯30æ—¥é–“æ›´æ–°ãŒã‚ã‚Šã¾ã›ã‚“ã€‚ã¾ã æœ‰åŠ¹ãªå ´åˆã¯ã‚³ãƒ¡ãƒ³ãƒˆã§æ›´æ–°ã—ã¦ãã ã•ã„ã€‚7æ—¥é–“å¿œç­”ãŒãªã„å ´åˆã€è‡ªå‹•çš„ã«ã‚¯ãƒ­ãƒ¼ã‚ºã•ã‚Œã¾ã™ã€‚'
                });

              } else if (updatedAt < sevenDaysAgo && hasStaleLabel) {
                // stale ãƒ©ãƒ™ãƒ«ãŒã¤ã„ã¦ã‹ã‚‰7æ—¥çµŒã£ãŸå ´åˆã¯ã‚¯ãƒ­ãƒ¼ã‚º
                await github.rest.issues.update({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issue.number,
                  state: 'closed'
                });

                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issue.number,
                  body: 'ğŸ”’ é•·æœŸé–“æ›´æ–°ãŒãªã‹ã£ãŸãŸã‚ã€ã“ã®ã‚¤ã‚·ãƒ¥ãƒ¼ã‚’è‡ªå‹•ã‚¯ãƒ­ãƒ¼ã‚ºã—ã¾ã—ãŸã€‚å¿…è¦ã«å¿œã˜ã¦å†ã‚ªãƒ¼ãƒ—ãƒ³ã—ã¦ãã ã•ã„ã€‚'
                });
              }
            }

  priority-analysis:
    runs-on: ubuntu-latest
    if: github.event_name == 'schedule' || github.event_name == 'workflow_dispatch'
    steps:
      - name: Analyze issue priorities
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const { data: issues } = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              per_page: 100
            });

            const priorities = {
              critical: [],
              high: [],
              medium: [],
              low: [],
              unlabeled: []
            };

            const categories = {
              security: [],
              performance: [],
              'machine-learning': [],
              'data-processing': [],
              testing: [],
              'parallel-processing': [],
              backtesting: [],
              hft: [],
              bug: [],
              enhancement: []
            };

            for (const issue of issues) {
              const labels = issue.labels.map(l => l.name);

              // å„ªå…ˆåº¦åˆ†æ
              if (labels.includes('critical')) {
                priorities.critical.push(issue);
              } else if (labels.includes('high-priority') || labels.includes('security')) {
                priorities.high.push(issue);
              } else if (labels.includes('medium-priority')) {
                priorities.medium.push(issue);
              } else if (labels.includes('low-priority')) {
                priorities.low.push(issue);
              } else {
                priorities.unlabeled.push(issue);
              }

              // ã‚«ãƒ†ã‚´ãƒªåˆ†æ
              for (const [category, list] of Object.entries(categories)) {
                if (labels.includes(category)) {
                  list.push(issue);
                }
              }
            }

            // ã‚µãƒãƒªãƒ¼ãƒ¬ãƒãƒ¼ãƒˆã®ä½œæˆ
            let report = '# Issue Triage Summary Report\n\n';
            report += `**Generated**: ${new Date().toISOString()}\n\n`;

            report += '## Priority Distribution\n';
            report += `- ğŸš¨ Critical: ${priorities.critical.length}\n`;
            report += `- âš ï¸ High: ${priorities.high.length}\n`;
            report += `- ğŸ“‹ Medium: ${priorities.medium.length}\n`;
            report += `- ğŸ“ Low: ${priorities.low.length}\n`;
            report += `- ğŸ·ï¸ Unlabeled: ${priorities.unlabeled.length}\n\n`;

            report += '## Category Distribution\n';
            for (const [category, list] of Object.entries(categories)) {
              if (list.length > 0) {
                report += `- ${category}: ${list.length}\n`;
              }
            }

            report += '\n## Action Items\n';

            if (priorities.critical.length > 0) {
              report += `- âš¡ ${priorities.critical.length} critical issues need immediate attention\n`;
            }

            if (priorities.unlabeled.length > 0) {
              report += `- ğŸ·ï¸ ${priorities.unlabeled.length} issues need labeling\n`;
            }

            if (categories.security.length > 0) {
              report += `- ğŸ”’ ${categories.security.length} security issues require review\n`;
            }

            // ã‚³ãƒ¡ãƒ³ãƒˆã¾ãŸã¯Issueã¨ã—ã¦ãƒ¬ãƒãƒ¼ãƒˆæŠ•ç¨¿
            console.log(report);

  duplicate-detection:
    runs-on: ubuntu-latest
    if: github.event_name == 'issues' && github.event.action == 'opened'
    steps:
      - name: Check for duplicates
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const newIssue = context.payload.issue;
            const newTitle = newIssue.title.toLowerCase();
            const newBody = newIssue.body?.toLowerCase() || '';

            const { data: existingIssues } = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'all',
              per_page: 100
            });

            const similarIssues = [];

            for (const issue of existingIssues) {
              if (issue.number === newIssue.number) continue;

              const title = issue.title.toLowerCase();
              const body = issue.body?.toLowerCase() || '';

              // ã‚·ãƒ³ãƒ—ãƒ«ãªé¡ä¼¼åº¦ãƒã‚§ãƒƒã‚¯
              const titleSimilarity = this.calculateSimilarity(newTitle, title);
              const bodySimilarity = this.calculateSimilarity(newBody, body);

              if (titleSimilarity > 0.7 || bodySimilarity > 0.5) {
                similarIssues.push({
                  issue: issue,
                  titleSimilarity: titleSimilarity,
                  bodySimilarity: bodySimilarity
                });
              }
            }

            if (similarIssues.length > 0) {
              let comment = 'ğŸ” **é¡ä¼¼ã‚¤ã‚·ãƒ¥ãƒ¼ãŒæ¤œå‡ºã•ã‚Œã¾ã—ãŸ**\n\n';
              comment += 'ä»¥ä¸‹ã®ã‚¤ã‚·ãƒ¥ãƒ¼ã¨é¡ä¼¼ã—ã¦ã„ã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™:\n\n';

              for (const similar of similarIssues.slice(0, 3)) {
                comment += `- #${similar.issue.number}: ${similar.issue.title}\n`;
                comment += `  - Status: ${similar.issue.state}\n`;
                comment += `  - é¡ä¼¼åº¦: ${Math.round(Math.max(similar.titleSimilarity, similar.bodySimilarity) * 100)}%\n\n`;
              }

              comment += 'é‡è¤‡ã—ã¦ã„ãªã„ã‹ã”ç¢ºèªãã ã•ã„ã€‚é‡è¤‡ã—ã¦ã„ã‚‹å ´åˆã¯ã€ã“ã®ã‚¤ã‚·ãƒ¥ãƒ¼ã‚’ã‚¯ãƒ­ãƒ¼ã‚ºã—ã¦æ—¢å­˜ã®ã‚¤ã‚·ãƒ¥ãƒ¼ã«ã‚³ãƒ¡ãƒ³ãƒˆã—ã¦ãã ã•ã„ã€‚';

              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: newIssue.number,
                body: comment
              });

              // é‡è¤‡å¯èƒ½æ€§ãƒ©ãƒ™ãƒ«ã‚’è¿½åŠ 
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: newIssue.number,
                labels: ['duplicate?']
              });
            }

            // ç°¡æ˜“çš„ãªé¡ä¼¼åº¦è¨ˆç®—é–¢æ•°
            this.calculateSimilarity = function(str1, str2) {
              const longer = str1.length > str2.length ? str1 : str2;
              const shorter = str1.length > str2.length ? str2 : str1;

              if (longer.length === 0) return 1.0;

              const distance = this.levenshteinDistance(longer, shorter);
              return (longer.length - distance) / longer.length;
            };

            this.levenshteinDistance = function(str1, str2) {
              const matrix = [];
              for (let i = 0; i <= str2.length; i++) {
                matrix[i] = [i];
              }
              for (let j = 0; j <= str1.length; j++) {
                matrix[0][j] = j;
              }
              for (let i = 1; i <= str2.length; i++) {
                for (let j = 1; j <= str1.length; j++) {
                  if (str2.charAt(i - 1) === str1.charAt(j - 1)) {
                    matrix[i][j] = matrix[i - 1][j - 1];
                  } else {
                    matrix[i][j] = Math.min(
                      matrix[i - 1][j - 1] + 1,
                      matrix[i][j - 1] + 1,
                      matrix[i - 1][j] + 1
                    );
                  }
                }
              }
              return matrix[str2.length][str1.length];
            };
