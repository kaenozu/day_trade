name: ğŸš¨ Enhanced Pull Request Conflict Detection

on:
  pull_request:
    types: [opened, synchronize, reopened]
  workflow_dispatch:
    inputs:
      target_branch:
        description: 'Target branch to check conflicts against'
        required: false
        default: ''
        type: string

permissions:
  contents: read
  pull-requests: write
  statuses: write

jobs:
  conflict-detection:
    runs-on: ubuntu-latest
    name: ğŸ” Advanced Conflict Detection

    steps:
      - name: ğŸ“¥ Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: ğŸ¯ Determine target branch
        id: target-branch
        run: |
          if [ -n "${{ github.event.inputs.target_branch }}" ]; then
            TARGET_BRANCH="${{ github.event.inputs.target_branch }}"
            echo "Using manual target branch: $TARGET_BRANCH"
          elif [ "${{ github.event_name }}" = "pull_request" ]; then
            TARGET_BRANCH="${{ github.base_ref }}"
            echo "Using PR base branch: $TARGET_BRANCH"
          else
            TARGET_BRANCH="main"
            echo "Using default target branch: $TARGET_BRANCH"
          fi

          echo "target_branch=$TARGET_BRANCH" >> $GITHUB_OUTPUT
          echo "TARGET_BRANCH=$TARGET_BRANCH" >> $GITHUB_ENV

      - name: ğŸ” Enhanced conflict detection
        id: conflict-check
        run: |
          set -e  # Exit on any error

          echo "ğŸ” Checking for merge conflicts with enhanced detection..."

          TARGET_BRANCH="${{ steps.target-branch.outputs.target_branch }}"
          CURRENT_BRANCH=$(git branch --show-current)

          echo "Source branch: $CURRENT_BRANCH"
          echo "Target branch: $TARGET_BRANCH"

          # Enhanced error handling for git operations
          cleanup_and_exit() {
            local exit_code=$1
            echo "ğŸ§¹ Performing cleanup..."
            git merge --abort 2>/dev/null || true
            git checkout "$CURRENT_BRANCH" 2>/dev/null || true
            git branch -D temp-merge-test 2>/dev/null || true
            exit $exit_code
          }

          # Fetch the latest target branch with retry logic
          echo "ğŸ“¥ Fetching latest $TARGET_BRANCH branch..."
          for i in {1..3}; do
            if git fetch origin "$TARGET_BRANCH:$TARGET_BRANCH" 2>&1; then
              echo "âœ… Successfully fetched $TARGET_BRANCH"
              break
            else
              echo "âš ï¸ Attempt $i failed, retrying..."
              if [ $i -eq 3 ]; then
                echo "âŒ Failed to fetch $TARGET_BRANCH after 3 attempts"
                exit 1
              fi
              sleep 2
            fi
          done

          # Try to merge target into current branch (dry run)
          echo "::group::Testing merge with $TARGET_BRANCH branch"

          # Create a temporary branch for testing merge with timestamp
          TEMP_BRANCH="temp-merge-test-$(date +%s)"
          if ! git checkout -b "$TEMP_BRANCH"; then
            echo "âŒ Failed to create temporary branch"
            exit 1
          fi

          # Attempt to merge target branch
          echo "ğŸ”„ Attempting merge with $TARGET_BRANCH..."
          if git merge "$TARGET_BRANCH" --no-commit --no-ff > merge_output.log 2>&1; then
            echo "âœ… No conflicts detected"
            echo "conflict_detected=false" >> $GITHUB_OUTPUT
            echo "CONFLICT_STATUS=no_conflicts" >> $GITHUB_ENV
            echo "conflicted_files=" >> $GITHUB_OUTPUT
            git merge --abort 2>/dev/null || true
          else
            echo "âš ï¸ Merge conflicts detected!"
            echo "conflict_detected=true" >> $GITHUB_OUTPUT
            echo "CONFLICT_STATUS=conflicts_found" >> $GITHUB_ENV

            # Enhanced conflicted files detection with proper quoting
            echo "ğŸ“ Analyzing conflicted files..."
            CONFLICTED_FILES_RAW=$(git diff --name-only --diff-filter=U 2>/dev/null || echo "")

            if [ -n "$CONFLICTED_FILES_RAW" ]; then
              # Handle files with spaces by using JSON array format
              CONFLICTED_FILES_JSON=$(echo "$CONFLICTED_FILES_RAW" | jq -R -s -c 'split("\n") | map(select(length > 0))')
              echo "conflicted_files_json=$CONFLICTED_FILES_JSON" >> $GITHUB_OUTPUT

              # Traditional space-separated format for backward compatibility
              CONFLICTED_FILES=$(echo "$CONFLICTED_FILES_RAW" | tr '\n' ' ' | sed 's/[[:space:]]*$//')
              echo "conflicted_files=$CONFLICTED_FILES" >> $GITHUB_OUTPUT
              echo "CONFLICTED_FILES=$CONFLICTED_FILES" >> $GITHUB_ENV

              echo "ğŸ“Š Conflicted files count: $(echo "$CONFLICTED_FILES_RAW" | wc -l)"
              echo "Conflicted files:"
              echo "$CONFLICTED_FILES_RAW" | sed 's/^/  - /'
            else
              echo "âš ï¸ Merge failed but no conflicted files detected"
              echo "conflicted_files=" >> $GITHUB_OUTPUT
              echo "conflicted_files_json=[]" >> $GITHUB_OUTPUT
            fi

            # Enhanced conflict details with better formatting
            echo "::group::ğŸ“‹ Detailed Conflict Analysis"
            if [ -f merge_output.log ]; then
              echo "Merge output:"
              cat merge_output.log
            else
              echo "No merge output available"
            fi

            # Additional conflict information
            echo ""
            echo "Git status during conflict:"
            git status --porcelain 2>/dev/null || echo "Unable to get git status"
            echo "::endgroup::"

            git merge --abort 2>/dev/null || true
          fi

          # Enhanced cleanup with better error handling
          echo "ğŸ§¹ Cleaning up temporary branch..."
          git checkout "$CURRENT_BRANCH" || cleanup_and_exit 1
          git branch -D "$TEMP_BRANCH" 2>/dev/null || {
            echo "âš ï¸ Warning: Could not delete temporary branch $TEMP_BRANCH"
          }

          echo "::endgroup::"

      - name: ğŸ” Check for existing conflict comments
        id: existing-comments
        if: steps.conflict-check.outputs.conflict_detected == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const comments = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number
            });

            // Look for existing conflict detection comments
            const conflictComments = comments.data.filter(comment =>
              comment.body.includes('ğŸš¨ Merge Conflicts Detected') ||
              comment.body.includes('âš ï¸ Merge Conflicts Detected') ||
              comment.body.includes('<!-- conflict-detection-comment -->')
            );

            console.log(`Found ${conflictComments.length} existing conflict comments`);

            // Return the most recent conflict comment ID if any
            const latestComment = conflictComments.length > 0 ? conflictComments[conflictComments.length - 1] : null;

            core.setOutput('has_existing_comment', conflictComments.length > 0);
            core.setOutput('latest_comment_id', latestComment ? latestComment.id : '');

            return {
              hasExisting: conflictComments.length > 0,
              latestId: latestComment ? latestComment.id : null,
              totalCount: conflictComments.length
            };

      - name: ğŸš¨ Create or update conflict summary comment
        if: steps.conflict-check.outputs.conflict_detected == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const targetBranch = '${{ steps.target-branch.outputs.target_branch }}';
            const conflictedFilesJson = '${{ steps.conflict-check.outputs.conflicted_files_json }}';
            const conflictedFiles = '${{ steps.conflict-check.outputs.conflicted_files }}';

            let conflictedFilesList = '';

            try {
              // Try to parse JSON format first for better handling
              const filesArray = JSON.parse(conflictedFilesJson || '[]');
              if (filesArray.length > 0) {
                conflictedFilesList = filesArray.map(file => `- \`${file}\``).join('\n');
              } else {
                // Fallback to space-separated format
                const files = conflictedFiles.split(' ').filter(f => f.trim());
                conflictedFilesList = files.map(file => `- \`${file}\``).join('\n');
              }
            } catch (e) {
              // Final fallback
              const files = conflictedFiles.split(' ').filter(f => f.trim());
              conflictedFilesList = files.map(file => `- \`${file}\``).join('\n');
            }

            if (!conflictedFilesList) {
              conflictedFilesList = '- _ã‚³ãƒ³ãƒ•ãƒªã‚¯ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ã®è©³ç´°ã‚’å–å¾—ã§ãã¾ã›ã‚“ã§ã—ãŸ_';
            }

            const currentTime = new Date().toISOString();
            const runUrl = `${context.payload.repository.html_url}/actions/runs/${context.runId}`;

            const body = [
              '<!-- conflict-detection-comment -->',
              '## ğŸš¨ Merge Conflicts Detected',
              '',
              `ã“ã®ãƒ—ãƒ«ãƒªã‚¯ã‚¨ã‚¹ãƒˆã¯ç¾åœ¨ **${targetBranch}** ãƒ–ãƒ©ãƒ³ãƒã¨ã®é–“ã§ã‚³ãƒ³ãƒ•ãƒªã‚¯ãƒˆãŒç™ºç”Ÿã—ã¦ã„ã¾ã™ã€‚`,
              '',
              '### ğŸ“ ã‚³ãƒ³ãƒ•ãƒªã‚¯ãƒˆãŒç™ºç”Ÿã—ã¦ã„ã‚‹ãƒ•ã‚¡ã‚¤ãƒ«:',
              conflictedFilesList,
              '',
              '### ğŸ”§ è§£æ±ºæ–¹æ³•:',
              '',
              `#### 1ï¸âƒ£ ãƒ­ãƒ¼ã‚«ãƒ«ã§${targetBranch}ãƒ–ãƒ©ãƒ³ãƒã‚’æœ€æ–°ã«ãƒ—ãƒ«:`,
              '```bash',
              `git checkout ${targetBranch}`,
              `git pull origin ${targetBranch}`,
              '```',
              '',
              `#### 2ï¸âƒ£ ãƒ•ã‚£ãƒ¼ãƒãƒ£ãƒ¼ãƒ–ãƒ©ãƒ³ãƒã«${targetBranch}ã‚’ãƒãƒ¼ã‚¸:`,
              '```bash',
              `git checkout ${context.payload.pull_request.head.ref}`,
              `git merge ${targetBranch}`,
              '```',
              '',
              '#### 3ï¸âƒ£ ã‚³ãƒ³ãƒ•ãƒªã‚¯ãƒˆã‚’æ‰‹å‹•ã§è§£æ±ºã—ã¦ã‚³ãƒŸãƒƒãƒˆ:',
              '```bash',
              '# ã‚³ãƒ³ãƒ•ãƒªã‚¯ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ã‚’ç·¨é›†ã—ã¦è§£æ±º',
              'git add .',
              `git commit -m "Resolve merge conflicts with ${targetBranch}"`,
              `git push origin ${context.payload.pull_request.head.ref}`,
              '```',
              '',
              '### ğŸ“Š æ¬¡ã®ã‚¹ãƒ†ãƒƒãƒ—:',
              '- [ ] ä¸Šè¨˜æ‰‹é †ã§ã‚³ãƒ³ãƒ•ãƒªã‚¯ãƒˆã‚’è§£æ±º',
              '- [ ] ãƒ†ã‚¹ãƒˆãŒé€šã‚‹ã“ã¨ã‚’ç¢ºèª',
              '- [ ] ãƒ—ãƒ«ãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’æ›´æ–°',
              '',
              '### ğŸ”„ è‡ªå‹•å†ãƒã‚§ãƒƒã‚¯',
              'ã‚³ãƒ³ãƒ•ãƒªã‚¯ãƒˆãŒè§£æ±ºã•ã‚Œã‚‹ã¨ã€ã“ã®ãƒã‚§ãƒƒã‚¯ã¯è‡ªå‹•çš„ã«å†å®Ÿè¡Œã•ã‚Œã¾ã™ã€‚',
              '',
              '---',
              `ğŸ“… **æœ€çµ‚ãƒã‚§ãƒƒã‚¯:** ${currentTime}`,
              `ğŸ”— **è©³ç´°ãƒ­ã‚°:** [ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼å®Ÿè¡Œçµæœ](${runUrl})`,
              '',
              '> ğŸ’¡ **ãƒ’ãƒ³ãƒˆ:** ã“ã®ã‚³ãƒ¡ãƒ³ãƒˆã¯è‡ªå‹•ç”Ÿæˆã•ã‚Œã¦ãŠã‚Šã€ã‚³ãƒ³ãƒ•ãƒªã‚¯ãƒˆçŠ¶æ³ã«å¿œã˜ã¦æ›´æ–°ã•ã‚Œã¾ã™ã€‚'
            ].join('\n');

            const hasExistingComment = '${{ steps.existing-comments.outputs.has_existing_comment }}' === 'true';
            const latestCommentId = '${{ steps.existing-comments.outputs.latest_comment_id }}';

            try {
              if (hasExistingComment && latestCommentId) {
                // Update existing comment
                console.log(`Updating existing conflict comment ${latestCommentId}`);
                await github.rest.issues.updateComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  comment_id: parseInt(latestCommentId),
                  body: body
                });
                console.log('âœ… Updated existing conflict comment');
              } else {
                // Create new comment
                console.log('Creating new conflict comment');
                const response = await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: context.issue.number,
                  body: body
                });
                console.log(`âœ… Created new conflict comment ${response.data.id}`);
              }
            } catch (error) {
              console.error('âŒ Failed to create/update conflict comment:', error.message);
              // Don't fail the workflow for comment errors
            }

      - name: ğŸ§¹ Clean up resolved conflict comments
        if: steps.conflict-check.outputs.conflict_detected == 'false'
        uses: actions/github-script@v7
        with:
          script: |
            console.log('ğŸ§¹ Checking for outdated conflict comments to clean up...');

            try {
              const comments = await github.rest.issues.listComments({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number
              });

              // Look for existing conflict detection comments
              const conflictComments = comments.data.filter(comment =>
                comment.body.includes('ğŸš¨ Merge Conflicts Detected') ||
                comment.body.includes('âš ï¸ Merge Conflicts Detected') ||
                comment.body.includes('<!-- conflict-detection-comment -->')
              );

              if (conflictComments.length > 0) {
                console.log(`Found ${conflictComments.length} outdated conflict comments`);

                // Add resolution notice to the latest conflict comment
                const latestComment = conflictComments[conflictComments.length - 1];
                const resolvedNotice = [
                  '',
                  '***** SEPARATOR *****',
                  '## âœ… **ã‚³ãƒ³ãƒ•ãƒªã‚¯ãƒˆè§£æ±ºæ¸ˆã¿**',
                  '',
                  'ã“ã®ãƒ—ãƒ«ãƒªã‚¯ã‚¨ã‚¹ãƒˆã®ãƒãƒ¼ã‚¸ã‚³ãƒ³ãƒ•ãƒªã‚¯ãƒˆã¯è§£æ±ºã•ã‚Œã¾ã—ãŸï¼ ğŸ‰',
                  '',
                  `ğŸ“… **è§£æ±ºç¢ºèªæ™‚åˆ»:** ${new Date().toISOString()}`,
                  `ğŸ”— **ç¢ºèªãƒ­ã‚°:** [ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼å®Ÿè¡Œçµæœ](${context.payload.repository.html_url}/actions/runs/${context.runId})`,
                  '',
                  '> ã“ã®ã‚³ãƒ¡ãƒ³ãƒˆã¯å±¥æ­´ã¨ã—ã¦æ®‹ã•ã‚Œã¦ã„ã¾ã™ãŒã€ç¾åœ¨ã¯ã‚³ãƒ³ãƒ•ãƒªã‚¯ãƒˆãŒå­˜åœ¨ã—ã¾ã›ã‚“ã€‚'
                ].join('\n');

                await github.rest.issues.updateComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  comment_id: latestComment.id,
                  body: latestComment.body + resolvedNotice
                });

                console.log(`âœ… Updated conflict comment with resolution notice`);
              } else {
                console.log('No conflict comments found to update');
              }
            } catch (error) {
              console.error('âš ï¸ Failed to clean up conflict comments:', error.message);
              // Don't fail the workflow for cleanup errors
            }

      - name: âœ… Success notification and metrics
        if: steps.conflict-check.outputs.conflict_detected == 'false'
        run: |
          echo "âœ… No merge conflicts detected with ${{ steps.target-branch.outputs.target_branch }}!"
          echo "ğŸ¯ Target branch: ${{ steps.target-branch.outputs.target_branch }}"
          echo "ğŸ“ This PR is ready for review and merge."

      - name: ğŸ“Š Enhanced status check
        uses: actions/github-script@v7
        with:
          script: |
            const conflictDetected = '${{ steps.conflict-check.outputs.conflict_detected }}' === 'true';
            const targetBranch = '${{ steps.target-branch.outputs.target_branch }}';
            const state = conflictDetected ? 'failure' : 'success';
            const description = conflictDetected
              ? `Merge conflicts detected with ${targetBranch}`
              : `No conflicts with ${targetBranch} - ready for merge`;

            try {
              await github.rest.repos.createCommitStatus({
                owner: context.repo.owner,
                repo: context.repo.repo,
                sha: context.payload.pull_request.head.sha,
                state: state,
                target_url: `${context.payload.repository.html_url}/actions/runs/${context.runId}`,
                description: description,
                context: 'ci/enhanced-conflict-detection'
              });

              console.log(`âœ… Status check created: ${state} - ${description}`);
            } catch (error) {
              console.error(`âŒ Failed to create status check: ${error.message}`);
            }

      - name: ğŸ“‹ Generate workflow summary
        run: |
          echo "## ğŸš¨ Enhanced Conflict Detection Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Target Branch:** \`${{ steps.target-branch.outputs.target_branch }}\`" >> $GITHUB_STEP_SUMMARY
          echo "**Source Branch:** \`${{ github.head_ref }}\`" >> $GITHUB_STEP_SUMMARY
          echo "**Result:** ${{ steps.conflict-check.outputs.conflict_detected == 'true' && 'ğŸ”´ Conflicts detected' || 'ğŸŸ¢ No conflicts' }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          if [ "${{ steps.conflict-check.outputs.conflict_detected }}" = "true" ]; then
            echo "### ğŸ“ Conflicted Files:" >> $GITHUB_STEP_SUMMARY
            echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
            echo "${{ steps.conflict-check.outputs.conflicted_files }}" | tr ' ' '\n' >> $GITHUB_STEP_SUMMARY
            echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "### ğŸ”§ Next Steps:" >> $GITHUB_STEP_SUMMARY
            echo "- Resolve conflicts locally using the instructions in the PR comment" >> $GITHUB_STEP_SUMMARY
            echo "- Push the resolved changes to trigger re-validation" >> $GITHUB_STEP_SUMMARY
          else
            echo "### âœ… Status:" >> $GITHUB_STEP_SUMMARY
            echo "- No merge conflicts detected" >> $GITHUB_STEP_SUMMARY
            echo "- Ready for review and merge" >> $GITHUB_STEP_SUMMARY
          fi

          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Workflow run:** [View details](${GITHUB_SERVER_URL}/${GITHUB_REPOSITORY}/actions/runs/${GITHUB_RUN_ID})" >> $GITHUB_STEP_SUMMARY

      - name: âŒ Fail job if conflicts detected
        if: steps.conflict-check.outputs.conflict_detected == 'true'
        run: |
          echo "âŒ Job failed due to merge conflicts with ${{ steps.target-branch.outputs.target_branch }}"
          echo "ğŸ“‹ Conflicted files: ${{ steps.conflict-check.outputs.conflicted_files }}"
          echo "ğŸ”§ Please resolve the conflicts and push the changes"
          echo "ğŸ“– Detailed instructions have been posted as a comment on this PR"
          exit 1
